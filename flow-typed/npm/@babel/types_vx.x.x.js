// flow-typed signature: a6c9e7be00b61487d4b231edefc154d8
// flow-typed version: <<STUB>>/@babel/types_v7.16.8/flow_v0.170.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   '@babel/types'
 *
 * Fill this stub out by replacing all the `mixed` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

// @flow

declare module '@babel/types' {
  declare interface BaseComment {
    end: number,
    loc: SourceLocation,
    start: number,
    type: 'CommentBlock' | 'CommentLine',
    value: string,
  }
  declare export

type CommentBlock = BaseComment & {
    type: 'CommentBlock',
    ...,
  };

  declare export type CommentLine = BaseComment & {
    type: 'CommentLine',
    ...,
  };

  declare export type Comment = CommentBlock | CommentLine;

  declare export interface SourceLocation {
    end: {
      column: number,
      line: number,
      ...,
    },
    start: {
      column: number,
      line: number,
      ...,
    },
  }
  declare interface BaseNode {
    end: number | null,
    extra?: { [key: string]: mixed, ... },
    innerComments: $ReadOnlyArray<Comment> | null,
    leadingComments: $ReadOnlyArray<Comment> | null,
    loc: SourceLocation | null,
    start: number | null,
    trailingComments: $ReadOnlyArray<Comment> | null,
    type: Node['type'],
  }

  declare export type Node =
    | AnyTypeAnnotation
    | ArgumentPlaceholder
    | ArrayExpression
    | ArrayPattern
    | ArrayTypeAnnotation
    | ArrowFunctionExpression
    | AssignmentExpression
    | AssignmentPattern
    | AwaitExpression
    | BigIntLiteral
    | Binary
    | BinaryExpression
    | BindExpression
    | Block
    | BlockParent
    | BlockStatement
    | BooleanLiteral
    | BooleanLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | BreakStatement
    | CallExpression
    | CatchClause
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | ClassImplements
    | ClassMethod
    | ClassPrivateMethod
    | ClassPrivateProperty
    | ClassProperty
    | CompletionStatement
    | Conditional
    | ConditionalExpression
    | ContinueStatement
    | DebuggerStatement
    | DecimalLiteral
    | Declaration
    | DeclareClass
    | DeclaredPredicate
    | DeclareExportAllDeclaration
    | DeclareExportDeclaration
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareOpaqueType
    | DeclareTypeAlias
    | DeclareVariable
    | Decorator
    | Directive
    | DirectiveLiteral
    | DoExpression
    | DoWhileStatement
    | EmptyStatement
    | EmptyTypeAnnotation
    | EnumBody
    | EnumBooleanBody
    | EnumBooleanMember
    | EnumDeclaration
    | EnumDefaultedMember
    | EnumMember
    | EnumNumberBody
    | EnumNumberMember
    | EnumStringBody
    | EnumStringMember
    | EnumSymbolBody
    | ExistsTypeAnnotation
    | ExportAllDeclaration
    | ExportDeclaration
    | ExportDefaultDeclaration
    | ExportDefaultSpecifier
    | ExportNamedDeclaration
    | ExportNamespaceSpecifier
    | ExportSpecifier
    | Expression
    | ExpressionStatement
    | ExpressionWrapper
    | File
    | Flow
    | FlowBaseAnnotation
    | FlowDeclaration
    | FlowPredicate
    | FlowType
    | For
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | ForXStatement
    | FunctionDeclaration
    | FunctionExpression
    | FunctionParent
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | IClass
    | Identifier
    | IfStatement
    | IFunction
    | Immutable
    | Import
    | ImportAttribute
    | ImportDeclaration
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | IndexedAccessType
    | InferredPredicate
    | InterfaceDeclaration
    | InterfaceExtends
    | InterfaceTypeAnnotation
    | InterpreterDirective
    | IntersectionTypeAnnotation
    | JSX
    | JSXAttribute
    | JSXClosingElement
    | JSXClosingFragment
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXFragment
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXOpeningFragment
    | JSXSpreadAttribute
    | JSXSpreadChild
    | JSXText
    | LabeledStatement
    | Literal
    | LogicalExpression
    | Loop
    | LVal
    | MemberExpression
    | MetaProperty
    | Method
    | Miscellaneous
    | MixedTypeAnnotation
    | ModuleDeclaration
    | ModuleExpression
    | ModuleSpecifier
    | NewExpression
    | Noop
    | NullableTypeAnnotation
    | NullLiteral
    | NullLiteralTypeAnnotation
    | NumberLiteral
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | NumericLiteral
    | ObjectExpression
    | ObjectMember
    | ObjectMethod
    | ObjectPattern
    | ObjectProperty
    | ObjectTypeAnnotation
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeInternalSlot
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | OptionalCallExpression
    | OptionalIndexedAccessType
    | OptionalMemberExpression
    | ParenthesizedExpression
    | Pattern
    | PatternLike
    | PipelineBareFunction
    | PipelinePrimaryTopicReference
    | PipelineTopicExpression
    | Placeholder
    | Private
    | PrivateName
    | Program
    | Property
    | Pureish
    | QualifiedTypeIdentifier
    | RecordExpression
    | RegexLiteral
    | RegExpLiteral
    | RestElement
    | RestProperty
    | ReturnStatement
    | Scopable
    | SequenceExpression
    | SpreadElement
    | SpreadProperty
    | Standardized
    | Statement
    | StaticBlock
    | StringLiteral
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | Super
    | SwitchCase
    | SwitchStatement
    | SymbolTypeAnnotation
    | TaggedTemplateExpression
    | TemplateElement
    | TemplateLiteral
    | Terminatorless
    | ThisExpression
    | ThisTypeAnnotation
    | ThrowStatement
    | TopicReference
    | TryStatement
    | TSAnyKeyword
    | TSArrayType
    | TSAsExpression
    | TSBaseType
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSCallSignatureDeclaration
    | TSConditionalType
    | TSConstructorType
    | TSConstructSignatureDeclaration
    | TSDeclareFunction
    | TSDeclareMethod
    | TSEntityName
    | TSEnumDeclaration
    | TSEnumMember
    | TSExportAssignment
    | TSExpressionWithTypeArguments
    | TSExternalModuleReference
    | TSFunctionType
    | TSImportEqualsDeclaration
    | TSImportType
    | TSIndexedAccessType
    | TSIndexSignature
    | TSInferType
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSIntersectionType
    | TSIntrinsicKeyword
    | TSLiteralType
    | TSMappedType
    | TSMethodSignature
    | TSModuleBlock
    | TSModuleDeclaration
    | TSNamedTupleMember
    | TSNamespaceExportDeclaration
    | TSNeverKeyword
    | TSNonNullExpression
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSOptionalType
    | TSParameterProperty
    | TSParenthesizedType
    | TSPropertySignature
    | TSQualifiedName
    | TSRestType
    | TSStringKeyword
    | TSSymbolKeyword
    | TSThisType
    | TSTupleType
    | TSType
    | TSTypeAliasDeclaration
    | TSTypeAnnotation
    | TSTypeAssertion
    | TSTypeElement
    | TSTypeLiteral
    | TSTypeOperator
    | TSTypeParameter
    | TSTypeParameterDeclaration
    | TSTypeParameterInstantiation
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeReference
    | TSUndefinedKeyword
    | TSUnionType
    | TSUnknownKeyword
    | TSVoidKeyword
    | TupleExpression
    | TupleTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeofTypeAnnotation
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | TypeScript
    | UnaryExpression
    | UnaryLike
    | UnionTypeAnnotation
    | UpdateExpression
    | UserWhitespacable
    | V8IntrinsicIdentifier
    | VariableDeclaration
    | VariableDeclarator
    | Variance
    | VoidTypeAnnotation
    | While
    | WhileStatement
    | WithStatement
    | YieldExpression;

  declare export type ArrayExpression = BaseNode & {
    elements: Array<Expression | SpreadElement | null>,
    type: 'ArrayExpression',
    ...,
  };

  declare export type AssignmentExpression = BaseNode & {
    left: LVal,
    operator: string,
    right: Expression,
    type: 'AssignmentExpression',
    ...,
  };

  declare export type BinaryExpression = BaseNode & {
    left: Expression | PrivateName,
    operator: | '-'
      | '!='
      | '!=='
      | '*'
      | '**'
      | '/'
      | '&'
      | '%'
      | '^'
      | '+'
      | '<'
      | '<<'
      | '<='
      | '=='
      | '==='
      | '>'
      | '>='
      | '>>'
      | '>>>'
      | '|'
      | 'in'
      | 'instanceof',
    right: Expression,
    type: 'BinaryExpression',
    ...,
  };

  declare export type InterpreterDirective = BaseNode & {
    type: 'InterpreterDirective',
    value: string,
    ...,
  };

  declare export type Directive = BaseNode & {
    type: 'Directive',
    value: DirectiveLiteral,
    ...,
  };

  declare export type DirectiveLiteral = BaseNode & {
    type: 'DirectiveLiteral',
    value: string,
    ...,
  };

  declare export type BlockStatement = BaseNode & {
    body: Statement[],
    directives: Directive[],
    type: 'BlockStatement',
    ...,
  };

  declare export type BreakStatement = BaseNode & {
    label: Identifier | null,
    type: 'BreakStatement',
    ...,
  };

  declare export type CallExpression = BaseNode & {
    arguments: Array<
      ArgumentPlaceholder | Expression | JSXNamespacedName | SpreadElement>,
    callee: Expression | V8IntrinsicIdentifier,
    optional: false | true | null,
    type: 'CallExpression',
    typeArguments: TypeParameterInstantiation | null,
    typeParameters: TSTypeParameterInstantiation | null,
    ...,
  };

  declare export type CatchClause = BaseNode & {
    body: BlockStatement,
    param: ArrayPattern | Identifier | ObjectPattern | null,
    type: 'CatchClause',
    ...,
  };

  declare export type ConditionalExpression = BaseNode & {
    alternate: Expression,
    consequent: Expression,
    test: Expression,
    type: 'ConditionalExpression',
    ...,
  };

  declare export type ContinueStatement = BaseNode & {
    label: Identifier | null,
    type: 'ContinueStatement',
    ...,
  };

  declare export type DebuggerStatement = BaseNode & {
    type: 'DebuggerStatement',
    ...,
  };

  declare export type DoWhileStatement = BaseNode & {
    body: Statement,
    test: Expression,
    type: 'DoWhileStatement',
    ...,
  };

  declare export type EmptyStatement = BaseNode & {
    type: 'EmptyStatement',
    ...,
  };

  declare export type ExpressionStatement = BaseNode & {
    expression: Expression,
    type: 'ExpressionStatement',
    ...,
  };

  declare export type File = BaseNode & {
    comments: Array<CommentBlock | CommentLine> | null,
    program: Program,
    tokens: mixed[] | null,
    type: 'File',
    ...,
  };

  declare export type ForInStatement = BaseNode & {
    body: Statement,
    left: LVal | VariableDeclaration,
    right: Expression,
    type: 'ForInStatement',
    ...,
  };

  declare export type ForStatement = BaseNode & {
    body: Statement,
    init: Expression | VariableDeclaration | null,
    test: Expression | null,
    type: 'ForStatement',
    update: Expression | null,
    ...,
  };

  declare export type FunctionDeclaration = BaseNode & {
    async: boolean,
    body: BlockStatement,
    declare: boolean | null,
    generator: boolean,
    id: Identifier | null,
    params: Array<Identifier | Pattern | RestElement>,
    returnType: Noop | TSTypeAnnotation | TypeAnnotation | null,
    type: 'FunctionDeclaration',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type FunctionExpression = BaseNode & {
    async: boolean,
    body: BlockStatement,
    generator: boolean,
    id: Identifier | null,
    params: Array<Identifier | Pattern | RestElement>,
    returnType: Noop | TSTypeAnnotation | TypeAnnotation | null,
    type: 'FunctionExpression',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type Identifier = BaseNode & {
    decorators: Decorator[] | null,
    name: string,
    optional: boolean | null,
    type: 'Identifier',
    typeAnnotation: Noop | TSTypeAnnotation | TypeAnnotation | null,
    ...,
  };

  declare export type IfStatement = BaseNode & {
    alternate: Statement | null,
    consequent: Statement,
    test: Expression,
    type: 'IfStatement',
    ...,
  };

  declare export type LabeledStatement = BaseNode & {
    body: Statement,
    label: Identifier,
    type: 'LabeledStatement',
    ...,
  };

  declare export type StringLiteral = BaseNode & {
    type: 'StringLiteral',
    value: string,
    ...,
  };

  declare export type NumericLiteral = BaseNode & {
    type: 'NumericLiteral',
    value: number,
    ...,
  };

  declare export type NullLiteral = BaseNode & {
    type: 'NullLiteral',
    ...,
  };

  declare export type BooleanLiteral = BaseNode & {
    type: 'BooleanLiteral',
    value: boolean,
    ...,
  };

  declare export type RegExpLiteral = BaseNode & {
    flags: string,
    pattern: string,
    type: 'RegExpLiteral',
    ...,
  };

  declare export type LogicalExpression = BaseNode & {
    left: Expression,
    operator: '??' | '&&' | '||',
    right: Expression,
    type: 'LogicalExpression',
    ...,
  };

  declare export type MemberExpression = BaseNode & {
    computed: boolean,
    object: Expression,
    optional: false | true | null,
    property: Expression | Identifier | PrivateName,
    type: 'MemberExpression',
    ...,
  };

  declare export type NewExpression = BaseNode & {
    arguments: Array<
      ArgumentPlaceholder | Expression | JSXNamespacedName | SpreadElement>,
    callee: Expression | V8IntrinsicIdentifier,
    optional: false | true | null,
    type: 'NewExpression',
    typeArguments: TypeParameterInstantiation | null,
    typeParameters: TSTypeParameterInstantiation | null,
    ...,
  };

  declare export type Program = BaseNode & {
    body: Statement[],
    directives: Directive[],
    interpreter: InterpreterDirective | null,
    sourceFile: string,
    sourceType: 'module' | 'script',
    type: 'Program',
    ...,
  };

  declare export type ObjectExpression = BaseNode & {
    properties: Array<ObjectMethod | ObjectProperty | SpreadElement>,
    type: 'ObjectExpression',
    ...,
  };

  declare export type ObjectMethod = BaseNode & {
    async: boolean,
    body: BlockStatement,
    computed: boolean,
    decorators: Decorator[] | null,
    generator: boolean,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    kind: 'get' | 'method' | 'set',
    params: Array<Identifier | Pattern | RestElement>,
    returnType: Noop | TSTypeAnnotation | TypeAnnotation | null,
    type: 'ObjectMethod',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type ObjectProperty = BaseNode & {
    computed: boolean,
    decorators: Decorator[] | null,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    shorthand: boolean,
    type: 'ObjectProperty',
    value: Expression | PatternLike,
    ...,
  };

  declare export type RestElement = BaseNode & {
    argument: LVal,
    decorators: Decorator[] | null,
    optional: boolean | null,
    type: 'RestElement',
    typeAnnotation: Noop | TSTypeAnnotation | TypeAnnotation | null,
    ...,
  };

  declare export type ReturnStatement = BaseNode & {
    argument: Expression | null,
    type: 'ReturnStatement',
    ...,
  };

  declare export type SequenceExpression = BaseNode & {
    expressions: Expression[],
    type: 'SequenceExpression',
    ...,
  };

  declare export type ParenthesizedExpression = BaseNode & {
    expression: Expression,
    type: 'ParenthesizedExpression',
    ...,
  };

  declare export type SwitchCase = BaseNode & {
    consequent: Statement[],
    test: Expression | null,
    type: 'SwitchCase',
    ...,
  };

  declare export type SwitchStatement = BaseNode & {
    cases: SwitchCase[],
    discriminant: Expression,
    type: 'SwitchStatement',
    ...,
  };

  declare export type ThisExpression = BaseNode & {
    type: 'ThisExpression',
    ...,
  };

  declare export type ThrowStatement = BaseNode & {
    argument: Expression,
    type: 'ThrowStatement',
    ...,
  };

  declare export type TryStatement = BaseNode & {
    block: BlockStatement,
    finalizer: BlockStatement | null,
    handler: CatchClause | null,
    type: 'TryStatement',
    ...,
  };

  declare export type UnaryExpression = BaseNode & {
    argument: Expression,
    operator: '-' | '!' | '+' | '~' | 'delete' | 'throw' | 'typeof' | 'void',
    prefix: boolean,
    type: 'UnaryExpression',
    ...,
  };

  declare export type UpdateExpression = BaseNode & {
    argument: Expression,
    operator: '--' | '++',
    prefix: boolean,
    type: 'UpdateExpression',
    ...,
  };

  declare export type VariableDeclaration = BaseNode & {
    declarations: VariableDeclarator[],
    declare: boolean | null,
    kind: 'const' | 'let' | 'var',
    type: 'VariableDeclaration',
    ...,
  };

  declare export type VariableDeclarator = BaseNode & {
    definite: boolean | null,
    id: LVal,
    init: Expression | null,
    type: 'VariableDeclarator',
    ...,
  };

  declare export type WhileStatement = BaseNode & {
    body: Statement,
    test: Expression,
    type: 'WhileStatement',
    ...,
  };

  declare export type WithStatement = BaseNode & {
    body: Statement,
    object: Expression,
    type: 'WithStatement',
    ...,
  };

  declare export type AssignmentPattern = BaseNode & {
    decorators: Decorator[] | null,
    left: ArrayPattern | Identifier | MemberExpression | ObjectPattern,
    right: Expression,
    type: 'AssignmentPattern',
    typeAnnotation: Noop | TSTypeAnnotation | TypeAnnotation | null,
    ...,
  };

  declare export type ArrayPattern = BaseNode & {
    decorators: Decorator[] | null,
    elements: Array<PatternLike | null>,
    optional: boolean | null,
    type: 'ArrayPattern',
    typeAnnotation: Noop | TSTypeAnnotation | TypeAnnotation | null,
    ...,
  };

  declare export type ArrowFunctionExpression = BaseNode & {
    async: boolean,
    body: BlockStatement | Expression,
    expression: boolean,
    generator: boolean,
    params: Array<Identifier | Pattern | RestElement>,
    returnType: Noop | TSTypeAnnotation | TypeAnnotation | null,
    type: 'ArrowFunctionExpression',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type ClassBody = BaseNode & {
    body: Array<
      | ClassMethod
      | ClassPrivateMethod
      | ClassPrivateProperty
      | ClassProperty
      | TSDeclareMethod
      | TSIndexSignature>,
    type: 'ClassBody',
    ...,
  };

  declare export type ClassExpression = BaseNode & {
    body: ClassBody,
    decorators: Decorator[] | null,
    id: Identifier | null,
    implements: Array<ClassImplements | TSExpressionWithTypeArguments> | null,
    mixins: InterfaceExtends | null,
    superClass: Expression | null,
    superTypeParameters: | TSTypeParameterInstantiation
      | TypeParameterInstantiation
      | null,
    type: 'ClassExpression',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type ClassDeclaration = BaseNode & {
    abstract: boolean | null,
    body: ClassBody,
    declare: boolean | null,
    decorators: Decorator[] | null,
    id: Identifier,
    implements: Array<ClassImplements | TSExpressionWithTypeArguments> | null,
    mixins: InterfaceExtends | null,
    superClass: Expression | null,
    superTypeParameters: | TSTypeParameterInstantiation
      | TypeParameterInstantiation
      | null,
    type: 'ClassDeclaration',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type ExportAllDeclaration = BaseNode & {
    assertions: ImportAttribute[] | null,
    exportKind: 'type' | 'value' | null,
    source: StringLiteral,
    type: 'ExportAllDeclaration',
    ...,
  };

  declare export type ExportDefaultDeclaration = BaseNode & {
    declaration: | ClassDeclaration
      | Expression
      | FunctionDeclaration
      | TSDeclareFunction,
    exportKind: 'value' | null,
    type: 'ExportDefaultDeclaration',
    ...,
  };

  declare export type ExportNamedDeclaration = BaseNode & {
    assertions: ImportAttribute[] | null,
    declaration: Declaration | null,
    exportKind: 'type' | 'value' | null,
    source: StringLiteral | null,
    specifiers: Array<
      ExportDefaultSpecifier | ExportNamespaceSpecifier | ExportSpecifier>,
    type: 'ExportNamedDeclaration',
    ...,
  };

  declare export type ExportSpecifier = BaseNode & {
    exported: Identifier | StringLiteral,
    exportKind: 'type' | 'value' | null,
    local: Identifier,
    type: 'ExportSpecifier',
    ...,
  };

  declare export type ForOfStatement = BaseNode & {
    await: boolean,
    body: Statement,
    left: LVal | VariableDeclaration,
    right: Expression,
    type: 'ForOfStatement',
    ...,
  };

  declare export type ImportDeclaration = BaseNode & {
    assertions: ImportAttribute[] | null,
    importKind: 'type' | 'typeof' | 'value' | null,
    source: StringLiteral,
    specifiers: Array<
      ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier>,
    type: 'ImportDeclaration',
    ...,
  };

  declare export type ImportDefaultSpecifier = BaseNode & {
    local: Identifier,
    type: 'ImportDefaultSpecifier',
    ...,
  };

  declare export type ImportNamespaceSpecifier = BaseNode & {
    local: Identifier,
    type: 'ImportNamespaceSpecifier',
    ...,
  };

  declare export type ImportSpecifier = BaseNode & {
    imported: Identifier | StringLiteral,
    importKind: 'type' | 'typeof' | 'value' | null,
    local: Identifier,
    type: 'ImportSpecifier',
    ...,
  };

  declare export type MetaProperty = BaseNode & {
    meta: Identifier,
    property: Identifier,
    type: 'MetaProperty',
    ...,
  };

  declare export type ClassMethod = BaseNode & {
    abstract: boolean | null,
    access: 'private' | 'protected' | 'public' | null,
    accessibility: 'private' | 'protected' | 'public' | null,
    async: boolean,
    body: BlockStatement,
    computed: boolean,
    decorators: Decorator[] | null,
    generator: boolean,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    kind: 'constructor' | 'get' | 'method' | 'set',
    optional: boolean | null,
    override: boolean,
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
    returnType: Noop | TSTypeAnnotation | TypeAnnotation | null,
    static: boolean,
    type: 'ClassMethod',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type ObjectPattern = BaseNode & {
    decorators: Decorator[] | null,
    properties: Array<ObjectProperty | RestElement>,
    type: 'ObjectPattern',
    typeAnnotation: Noop | TSTypeAnnotation | TypeAnnotation | null,
    ...,
  };

  declare export type SpreadElement = BaseNode & {
    argument: Expression,
    type: 'SpreadElement',
    ...,
  };

  declare export type Super = BaseNode & {
    type: 'Super',
    ...,
  };

  declare export type TaggedTemplateExpression = BaseNode & {
    quasi: TemplateLiteral,
    tag: Expression,
    type: 'TaggedTemplateExpression',
    typeParameters: | TSTypeParameterInstantiation
      | TypeParameterInstantiation
      | null,
    ...,
  };

  declare export type TemplateElement = BaseNode & {
    tail: boolean,
    type: 'TemplateElement',
    value: {
      cooked?: string,
      raw: string,
      ...,
    },
    ...,
  };

  declare export type TemplateLiteral = BaseNode & {
    expressions: Array<Expression | TSType>,
    quasis: TemplateElement[],
    type: 'TemplateLiteral',
    ...,
  };

  declare export type YieldExpression = BaseNode & {
    argument: Expression | null,
    delegate: boolean,
    type: 'YieldExpression',
    ...,
  };

  declare export type AwaitExpression = BaseNode & {
    argument: Expression,
    type: 'AwaitExpression',
    ...,
  };

  declare export type Import = BaseNode & {
    type: 'Import',
    ...,
  };

  declare export type BigIntLiteral = BaseNode & {
    type: 'BigIntLiteral',
    value: string,
    ...,
  };

  declare export type ExportNamespaceSpecifier = BaseNode & {
    exported: Identifier,
    type: 'ExportNamespaceSpecifier',
    ...,
  };

  declare export type OptionalMemberExpression = BaseNode & {
    computed: boolean,
    object: Expression,
    optional: boolean,
    property: Expression | Identifier,
    type: 'OptionalMemberExpression',
    ...,
  };

  declare export type OptionalCallExpression = BaseNode & {
    arguments: Array<
      ArgumentPlaceholder | Expression | JSXNamespacedName | SpreadElement>,
    callee: Expression,
    optional: boolean,
    type: 'OptionalCallExpression',
    typeArguments: TypeParameterInstantiation | null,
    typeParameters: TSTypeParameterInstantiation | null,
    ...,
  };

  declare export type ClassProperty = BaseNode & {
    abstract: boolean | null,
    accessibility: 'private' | 'protected' | 'public' | null,
    computed: boolean,
    declare: boolean | null,
    decorators: Decorator[] | null,
    definite: boolean | null,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    optional: boolean | null,
    override: boolean,
    readonly: boolean | null,
    static: boolean,
    type: 'ClassProperty',
    typeAnnotation: Noop | TSTypeAnnotation | TypeAnnotation | null,
    value: Expression | null,
    variance: Variance | null,
    ...,
  };

  declare export type ClassPrivateProperty = BaseNode & {
    decorators: Decorator[] | null,
    definite: boolean | null,
    key: PrivateName,
    readonly: boolean | null,
    static: mixed,
    type: 'ClassPrivateProperty',
    typeAnnotation: Noop | TSTypeAnnotation | TypeAnnotation | null,
    value: Expression | null,
    variance: Variance | null,
    ...,
  };

  declare export type ClassPrivateMethod = BaseNode & {
    abstract: boolean | null,
    access: 'private' | 'protected' | 'public' | null,
    accessibility: 'private' | 'protected' | 'public' | null,
    async: boolean,
    body: BlockStatement,
    computed: boolean,
    decorators: Decorator[] | null,
    generator: boolean,
    key: PrivateName,
    kind: 'constructor' | 'get' | 'method' | 'set',
    optional: boolean | null,
    override: boolean,
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
    returnType: Noop | TSTypeAnnotation | TypeAnnotation | null,
    static: boolean,
    type: 'ClassPrivateMethod',
    typeParameters: | Noop
      | TSTypeParameterDeclaration
      | TypeParameterDeclaration
      | null,
    ...,
  };

  declare export type PrivateName = BaseNode & {
    id: Identifier,
    type: 'PrivateName',
    ...,
  };

  declare export type StaticBlock = BaseNode & {
    body: Statement[],
    type: 'StaticBlock',
    ...,
  };

  declare export type AnyTypeAnnotation = BaseNode & {
    type: 'AnyTypeAnnotation',
    ...,
  };

  declare export type ArrayTypeAnnotation = BaseNode & {
    elementType: FlowType,
    type: 'ArrayTypeAnnotation',
    ...,
  };

  declare export type BooleanTypeAnnotation = BaseNode & {
    type: 'BooleanTypeAnnotation',
    ...,
  };

  declare export type BooleanLiteralTypeAnnotation = BaseNode & {
    type: 'BooleanLiteralTypeAnnotation',
    value: boolean,
    ...,
  };

  declare export type NullLiteralTypeAnnotation = BaseNode & {
    type: 'NullLiteralTypeAnnotation',
    ...,
  };

  declare export type ClassImplements = BaseNode & {
    id: Identifier,
    type: 'ClassImplements',
    typeParameters: TypeParameterInstantiation | null,
    ...,
  };

  declare export type DeclareClass = BaseNode & {
    body: ObjectTypeAnnotation,
    extends: InterfaceExtends[] | null,
    id: Identifier,
    implements: ClassImplements[] | null,
    mixins: InterfaceExtends[] | null,
    type: 'DeclareClass',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type DeclareFunction = BaseNode & {
    id: Identifier,
    predicate: DeclaredPredicate | null,
    type: 'DeclareFunction',
    ...,
  };

  declare export type DeclareInterface = BaseNode & {
    body: ObjectTypeAnnotation,
    extends: InterfaceExtends[] | null,
    id: Identifier,
    implements: ClassImplements[] | null,
    mixins: InterfaceExtends[] | null,
    type: 'DeclareInterface',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type DeclareModule = BaseNode & {
    body: BlockStatement,
    id: Identifier | StringLiteral,
    kind: 'CommonJS' | 'ES' | null,
    type: 'DeclareModule',
    ...,
  };

  declare export type DeclareModuleExports = BaseNode & {
    type: 'DeclareModuleExports',
    typeAnnotation: TypeAnnotation,
    ...,
  };

  declare export type DeclareTypeAlias = BaseNode & {
    id: Identifier,
    right: FlowType,
    type: 'DeclareTypeAlias',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type DeclareOpaqueType = BaseNode & {
    id: Identifier,
    impltype: FlowType | null,
    supertype: FlowType | null,
    type: 'DeclareOpaqueType',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type DeclareVariable = BaseNode & {
    id: Identifier,
    type: 'DeclareVariable',
    ...,
  };

  declare export type DeclareExportDeclaration = BaseNode & {
    declaration: Flow | null,
    default: boolean | null,
    source: StringLiteral | null,
    specifiers: Array<ExportNamespaceSpecifier | ExportSpecifier> | null,
    type: 'DeclareExportDeclaration',
    ...,
  };

  declare export type DeclareExportAllDeclaration = BaseNode & {
    exportKind: 'type' | 'value' | null,
    source: StringLiteral,
    type: 'DeclareExportAllDeclaration',
    ...,
  };

  declare export type DeclaredPredicate = BaseNode & {
    type: 'DeclaredPredicate',
    value: Flow,
    ...,
  };

  declare export type ExistsTypeAnnotation = BaseNode & {
    type: 'ExistsTypeAnnotation',
    ...,
  };

  declare export type FunctionTypeAnnotation = BaseNode & {
    params: FunctionTypeParam[],
    rest: FunctionTypeParam | null,
    returnType: FlowType,
    this: FunctionTypeParam | null,
    type: 'FunctionTypeAnnotation',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type FunctionTypeParam = BaseNode & {
    name: Identifier | null,
    optional: boolean | null,
    type: 'FunctionTypeParam',
    typeAnnotation: FlowType,
    ...,
  };

  declare export type GenericTypeAnnotation = BaseNode & {
    id: Identifier | QualifiedTypeIdentifier,
    type: 'GenericTypeAnnotation',
    typeParameters: TypeParameterInstantiation | null,
    ...,
  };

  declare export type InferredPredicate = BaseNode & {
    type: 'InferredPredicate',
    ...,
  };

  declare export type InterfaceExtends = BaseNode & {
    id: Identifier | QualifiedTypeIdentifier,
    type: 'InterfaceExtends',
    typeParameters: TypeParameterInstantiation | null,
    ...,
  };

  declare export type InterfaceDeclaration = BaseNode & {
    body: ObjectTypeAnnotation,
    extends: InterfaceExtends[] | null,
    id: Identifier,
    implements: ClassImplements[] | null,
    mixins: InterfaceExtends[] | null,
    type: 'InterfaceDeclaration',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type InterfaceTypeAnnotation = BaseNode & {
    body: ObjectTypeAnnotation,
    extends: InterfaceExtends[] | null,
    type: 'InterfaceTypeAnnotation',
    ...,
  };

  declare export type IntersectionTypeAnnotation = BaseNode & {
    type: 'IntersectionTypeAnnotation',
    types: FlowType[],
    ...,
  };

  declare export type MixedTypeAnnotation = BaseNode & {
    type: 'MixedTypeAnnotation',
    ...,
  };

  declare export type EmptyTypeAnnotation = BaseNode & {
    type: 'EmptyTypeAnnotation',
    ...,
  };

  declare export type NullableTypeAnnotation = BaseNode & {
    type: 'NullableTypeAnnotation',
    typeAnnotation: FlowType,
    ...,
  };

  declare export type NumberLiteralTypeAnnotation = BaseNode & {
    type: 'NumberLiteralTypeAnnotation',
    value: number,
    ...,
  };

  declare export type NumberTypeAnnotation = BaseNode & {
    type: 'NumberTypeAnnotation',
    ...,
  };

  declare export type ObjectTypeAnnotation = BaseNode & {
    callProperties: ObjectTypeCallProperty[] | null,
    exact: boolean,
    indexers: ObjectTypeIndexer[] | null,
    inexact: boolean | null,
    internalSlots: ObjectTypeInternalSlot[] | null,
    properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>,
    type: 'ObjectTypeAnnotation',
    ...,
  };

  declare export type ObjectTypeInternalSlot = BaseNode & {
    id: Identifier,
    method: boolean,
    optional: boolean,
    static: boolean,
    type: 'ObjectTypeInternalSlot',
    value: FlowType,
    ...,
  };

  declare export type ObjectTypeCallProperty = BaseNode & {
    static: boolean,
    type: 'ObjectTypeCallProperty',
    value: FlowType,
    ...,
  };

  declare export type ObjectTypeIndexer = BaseNode & {
    id: Identifier | null,
    key: FlowType,
    static: boolean,
    type: 'ObjectTypeIndexer',
    value: FlowType,
    variance: Variance | null,
    ...,
  };

  declare export type ObjectTypeProperty = BaseNode & {
    key: Identifier | StringLiteral,
    kind: 'get' | 'init' | 'set',
    method: boolean,
    optional: boolean,
    proto: boolean,
    static: boolean,
    type: 'ObjectTypeProperty',
    value: FlowType,
    variance: Variance | null,
    ...,
  };

  declare export type ObjectTypeSpreadProperty = BaseNode & {
    argument: FlowType,
    type: 'ObjectTypeSpreadProperty',
    ...,
  };

  declare export type OpaqueType = BaseNode & {
    id: Identifier,
    impltype: FlowType,
    supertype: FlowType | null,
    type: 'OpaqueType',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type QualifiedTypeIdentifier = BaseNode & {
    id: Identifier,
    qualification: Identifier | QualifiedTypeIdentifier,
    type: 'QualifiedTypeIdentifier',
    ...,
  };

  declare export type StringLiteralTypeAnnotation = BaseNode & {
    type: 'StringLiteralTypeAnnotation',
    value: string,
    ...,
  };

  declare export type StringTypeAnnotation = BaseNode & {
    type: 'StringTypeAnnotation',
    ...,
  };

  declare export type SymbolTypeAnnotation = BaseNode & {
    type: 'SymbolTypeAnnotation',
    ...,
  };

  declare export type ThisTypeAnnotation = BaseNode & {
    type: 'ThisTypeAnnotation',
    ...,
  };

  declare export type TupleTypeAnnotation = BaseNode & {
    type: 'TupleTypeAnnotation',
    types: FlowType[],
    ...,
  };

  declare export type TypeofTypeAnnotation = BaseNode & {
    argument: FlowType,
    type: 'TypeofTypeAnnotation',
    ...,
  };

  declare export type TypeAlias = BaseNode & {
    id: Identifier,
    right: FlowType,
    type: 'TypeAlias',
    typeParameters: TypeParameterDeclaration | null,
    ...,
  };

  declare export type TypeAnnotation = BaseNode & {
    type: 'TypeAnnotation',
    typeAnnotation: FlowType,
    ...,
  };

  declare export type TypeCastExpression = BaseNode & {
    expression: Expression,
    type: 'TypeCastExpression',
    typeAnnotation: TypeAnnotation,
    ...,
  };

  declare export type TypeParameter = BaseNode & {
    bound: TypeAnnotation | null,
    default: FlowType | null,
    name: string,
    type: 'TypeParameter',
    variance: Variance | null,
    ...,
  };

  declare export type TypeParameterDeclaration = BaseNode & {
    params: TypeParameter[],
    type: 'TypeParameterDeclaration',
    ...,
  };

  declare export type TypeParameterInstantiation = BaseNode & {
    params: FlowType[],
    type: 'TypeParameterInstantiation',
    ...,
  };

  declare export type UnionTypeAnnotation = BaseNode & {
    type: 'UnionTypeAnnotation',
    types: FlowType[],
    ...,
  };

  declare export type Variance = BaseNode & {
    kind: 'minus' | 'plus',
    type: 'Variance',
    ...,
  };

  declare export type VoidTypeAnnotation = BaseNode & {
    type: 'VoidTypeAnnotation',
    ...,
  };

  declare export type EnumDeclaration = BaseNode & {
    body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody,
    id: Identifier,
    type: 'EnumDeclaration',
    ...,
  };

  declare export type EnumBooleanBody = BaseNode & {
    explicitType: boolean,
    hasUnknownMembers: boolean,
    members: EnumBooleanMember[],
    type: 'EnumBooleanBody',
    ...,
  };

  declare export type EnumNumberBody = BaseNode & {
    explicitType: boolean,
    hasUnknownMembers: boolean,
    members: EnumNumberMember[],
    type: 'EnumNumberBody',
    ...,
  };

  declare export type EnumStringBody = BaseNode & {
    explicitType: boolean,
    hasUnknownMembers: boolean,
    members: Array<EnumDefaultedMember | EnumStringMember>,
    type: 'EnumStringBody',
    ...,
  };

  declare export type EnumSymbolBody = BaseNode & {
    hasUnknownMembers: boolean,
    members: EnumDefaultedMember[],
    type: 'EnumSymbolBody',
    ...,
  };

  declare export type EnumBooleanMember = BaseNode & {
    id: Identifier,
    init: BooleanLiteral,
    type: 'EnumBooleanMember',
    ...,
  };

  declare export type EnumNumberMember = BaseNode & {
    id: Identifier,
    init: NumericLiteral,
    type: 'EnumNumberMember',
    ...,
  };

  declare export type EnumStringMember = BaseNode & {
    id: Identifier,
    init: StringLiteral,
    type: 'EnumStringMember',
    ...,
  };

  declare export type EnumDefaultedMember = BaseNode & {
    id: Identifier,
    type: 'EnumDefaultedMember',
    ...,
  };

  declare export type IndexedAccessType = BaseNode & {
    indexType: FlowType,
    objectType: FlowType,
    type: 'IndexedAccessType',
    ...,
  };

  declare export type OptionalIndexedAccessType = BaseNode & {
    indexType: FlowType,
    objectType: FlowType,
    optional: boolean,
    type: 'OptionalIndexedAccessType',
    ...,
  };

  declare export type JSXAttribute = BaseNode & {
    name: JSXIdentifier | JSXNamespacedName,
    type: 'JSXAttribute',
    value: | JSXElement
      | JSXExpressionContainer
      | JSXFragment
      | StringLiteral
      | null,
    ...,
  };

  declare export type JSXClosingElement = BaseNode & {
    name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
    type: 'JSXClosingElement',
    ...,
  };

  declare export type JSXElement = BaseNode & {
    children: Array<
      | JSXElement
      | JSXExpressionContainer
      | JSXFragment
      | JSXSpreadChild
      | JSXText>,
    closingElement: JSXClosingElement | null,
    openingElement: JSXOpeningElement,
    selfClosing: boolean | null,
    type: 'JSXElement',
    ...,
  };

  declare export type JSXEmptyExpression = BaseNode & {
    type: 'JSXEmptyExpression',
    ...,
  };

  declare export type JSXExpressionContainer = BaseNode & {
    expression: Expression | JSXEmptyExpression,
    type: 'JSXExpressionContainer',
    ...,
  };

  declare export type JSXSpreadChild = BaseNode & {
    expression: Expression,
    type: 'JSXSpreadChild',
    ...,
  };

  declare export type JSXIdentifier = BaseNode & {
    name: string,
    type: 'JSXIdentifier',
    ...,
  };

  declare export type JSXMemberExpression = BaseNode & {
    object: JSXIdentifier | JSXMemberExpression,
    property: JSXIdentifier,
    type: 'JSXMemberExpression',
    ...,
  };

  declare export type JSXNamespacedName = BaseNode & {
    name: JSXIdentifier,
    namespace: JSXIdentifier,
    type: 'JSXNamespacedName',
    ...,
  };

  declare export type JSXOpeningElement = BaseNode & {
    attributes: Array<JSXAttribute | JSXSpreadAttribute>,
    name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
    selfClosing: boolean,
    type: 'JSXOpeningElement',
    typeParameters: | TSTypeParameterInstantiation
      | TypeParameterInstantiation
      | null,
    ...,
  };

  declare export type JSXSpreadAttribute = BaseNode & {
    argument: Expression,
    type: 'JSXSpreadAttribute',
    ...,
  };

  declare export type JSXText = BaseNode & {
    type: 'JSXText',
    value: string,
    ...,
  };

  declare export type JSXFragment = BaseNode & {
    children: Array<
      | JSXElement
      | JSXExpressionContainer
      | JSXFragment
      | JSXSpreadChild
      | JSXText>,
    closingFragment: JSXClosingFragment,
    openingFragment: JSXOpeningFragment,
    type: 'JSXFragment',
    ...,
  };

  declare export type JSXOpeningFragment = BaseNode & {
    type: 'JSXOpeningFragment',
    ...,
  };

  declare export type JSXClosingFragment = BaseNode & {
    type: 'JSXClosingFragment',
    ...,
  };

  declare export type Noop = BaseNode & {
    type: 'Noop',
    ...,
  };

  declare export type Placeholder = BaseNode & {
    expectedNode: | 'BlockStatement'
      | 'ClassBody'
      | 'Declaration'
      | 'Expression'
      | 'Identifier'
      | 'Pattern'
      | 'Statement'
      | 'StringLiteral',
    name: Identifier,
    type: 'Placeholder',
    ...,
  };

  declare export type V8IntrinsicIdentifier = BaseNode & {
    name: string,
    type: 'V8IntrinsicIdentifier',
    ...,
  };

  declare export type ArgumentPlaceholder = BaseNode & {
    type: 'ArgumentPlaceholder',
    ...,
  };

  declare export type BindExpression = BaseNode & {
    callee: Expression,
    object: Expression,
    type: 'BindExpression',
    ...,
  };

  declare export type ImportAttribute = BaseNode & {
    key: Identifier | StringLiteral,
    type: 'ImportAttribute',
    value: StringLiteral,
    ...,
  };

  declare export type Decorator = BaseNode & {
    expression: Expression,
    type: 'Decorator',
    ...,
  };

  declare export type DoExpression = BaseNode & {
    async: boolean,
    body: BlockStatement,
    type: 'DoExpression',
    ...,
  };

  declare export type ExportDefaultSpecifier = BaseNode & {
    exported: Identifier,
    type: 'ExportDefaultSpecifier',
    ...,
  };

  declare export type RecordExpression = BaseNode & {
    properties: Array<ObjectProperty | SpreadElement>,
    type: 'RecordExpression',
    ...,
  };

  declare export type TupleExpression = BaseNode & {
    elements: Array<Expression | SpreadElement>,
    type: 'TupleExpression',
    ...,
  };

  declare export type DecimalLiteral = BaseNode & {
    type: 'DecimalLiteral',
    value: string,
    ...,
  };

  declare export type ModuleExpression = BaseNode & {
    body: Program,
    type: 'ModuleExpression',
    ...,
  };

  declare export type TopicReference = BaseNode & {
    type: 'TopicReference',
    ...,
  };

  declare export type PipelineTopicExpression = BaseNode & {
    expression: Expression,
    type: 'PipelineTopicExpression',
    ...,
  };

  declare export type PipelineBareFunction = BaseNode & {
    callee: Expression,
    type: 'PipelineBareFunction',
    ...,
  };

  declare export type PipelinePrimaryTopicReference = BaseNode & {
    type: 'PipelinePrimaryTopicReference',
    ...,
  };

  declare export type TSParameterProperty = BaseNode & {
    accessibility: 'private' | 'protected' | 'public' | null,
    decorators: Decorator[] | null,
    override: boolean | null,
    parameter: AssignmentPattern | Identifier,
    readonly: boolean | null,
    type: 'TSParameterProperty',
    ...,
  };

  declare export type TSDeclareFunction = BaseNode & {
    async: boolean,
    declare: boolean | null,
    generator: boolean,
    id: Identifier | null,
    params: Array<Identifier | Pattern | RestElement>,
    returnType: Noop | TSTypeAnnotation | null,
    type: 'TSDeclareFunction',
    typeParameters: Noop | TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSDeclareMethod = BaseNode & {
    abstract: boolean | null,
    access: 'private' | 'protected' | 'public' | null,
    accessibility: 'private' | 'protected' | 'public' | null,
    async: boolean,
    computed: boolean,
    decorators: Decorator[] | null,
    generator: boolean,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    kind: 'constructor' | 'get' | 'method' | 'set',
    optional: boolean | null,
    override: boolean,
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
    returnType: Noop | TSTypeAnnotation | null,
    static: boolean,
    type: 'TSDeclareMethod',
    typeParameters: Noop | TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSQualifiedName = BaseNode & {
    left: TSEntityName,
    right: Identifier,
    type: 'TSQualifiedName',
    ...,
  };

  declare export type TSCallSignatureDeclaration = BaseNode & {
    parameters: Array<Identifier | RestElement>,
    type: 'TSCallSignatureDeclaration',
    typeAnnotation: TSTypeAnnotation | null,
    typeParameters: TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSConstructSignatureDeclaration = BaseNode & {
    parameters: Array<Identifier | RestElement>,
    type: 'TSConstructSignatureDeclaration',
    typeAnnotation: TSTypeAnnotation | null,
    typeParameters: TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSPropertySignature = BaseNode & {
    computed: boolean | null,
    initializer: Expression | null,
    key: Expression,
    kind: 'get' | 'set',
    optional: boolean | null,
    readonly: boolean | null,
    type: 'TSPropertySignature',
    typeAnnotation: TSTypeAnnotation | null,
    ...,
  };

  declare export type TSMethodSignature = BaseNode & {
    computed: boolean | null,
    key: Expression,
    kind: 'get' | 'method' | 'set',
    optional: boolean | null,
    parameters: Array<Identifier | RestElement>,
    type: 'TSMethodSignature',
    typeAnnotation: TSTypeAnnotation | null,
    typeParameters: TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSIndexSignature = BaseNode & {
    parameters: Identifier[],
    readonly: boolean | null,
    static: boolean | null,
    type: 'TSIndexSignature',
    typeAnnotation: TSTypeAnnotation | null,
    ...,
  };

  declare export type TSAnyKeyword = BaseNode & {
    type: 'TSAnyKeyword',
    ...,
  };

  declare export type TSBooleanKeyword = BaseNode & {
    type: 'TSBooleanKeyword',
    ...,
  };

  declare export type TSBigIntKeyword = BaseNode & {
    type: 'TSBigIntKeyword',
    ...,
  };

  declare export type TSIntrinsicKeyword = BaseNode & {
    type: 'TSIntrinsicKeyword',
    ...,
  };

  declare export type TSNeverKeyword = BaseNode & {
    type: 'TSNeverKeyword',
    ...,
  };

  declare export type TSNullKeyword = BaseNode & {
    type: 'TSNullKeyword',
    ...,
  };

  declare export type TSNumberKeyword = BaseNode & {
    type: 'TSNumberKeyword',
    ...,
  };

  declare export type TSObjectKeyword = BaseNode & {
    type: 'TSObjectKeyword',
    ...,
  };

  declare export type TSStringKeyword = BaseNode & {
    type: 'TSStringKeyword',
    ...,
  };

  declare export type TSSymbolKeyword = BaseNode & {
    type: 'TSSymbolKeyword',
    ...,
  };

  declare export type TSUndefinedKeyword = BaseNode & {
    type: 'TSUndefinedKeyword',
    ...,
  };

  declare export type TSUnknownKeyword = BaseNode & {
    type: 'TSUnknownKeyword',
    ...,
  };

  declare export type TSVoidKeyword = BaseNode & {
    type: 'TSVoidKeyword',
    ...,
  };

  declare export type TSThisType = BaseNode & {
    type: 'TSThisType',
    ...,
  };

  declare export type TSFunctionType = BaseNode & {
    parameters: Array<Identifier | RestElement>,
    type: 'TSFunctionType',
    typeAnnotation: TSTypeAnnotation | null,
    typeParameters: TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSConstructorType = BaseNode & {
    abstract: boolean | null,
    parameters: Array<Identifier | RestElement>,
    type: 'TSConstructorType',
    typeAnnotation: TSTypeAnnotation | null,
    typeParameters: TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSTypeReference = BaseNode & {
    type: 'TSTypeReference',
    typeName: TSEntityName,
    typeParameters: TSTypeParameterInstantiation | null,
    ...,
  };

  declare export type TSTypePredicate = BaseNode & {
    asserts: boolean | null,
    parameterName: Identifier | TSThisType,
    type: 'TSTypePredicate',
    typeAnnotation: TSTypeAnnotation | null,
    ...,
  };

  declare export type TSTypeQuery = BaseNode & {
    exprName: TSEntityName | TSImportType,
    type: 'TSTypeQuery',
    ...,
  };

  declare export type TSTypeLiteral = BaseNode & {
    members: TSTypeElement[],
    type: 'TSTypeLiteral',
    ...,
  };

  declare export type TSArrayType = BaseNode & {
    elementType: TSType,
    type: 'TSArrayType',
    ...,
  };

  declare export type TSTupleType = BaseNode & {
    elementTypes: Array<TSNamedTupleMember | TSType>,
    type: 'TSTupleType',
    ...,
  };

  declare export type TSOptionalType = BaseNode & {
    type: 'TSOptionalType',
    typeAnnotation: TSType,
    ...,
  };

  declare export type TSRestType = BaseNode & {
    type: 'TSRestType',
    typeAnnotation: TSType,
    ...,
  };

  declare export type TSNamedTupleMember = BaseNode & {
    elementType: TSType,
    label: Identifier,
    optional: boolean,
    type: 'TSNamedTupleMember',
    ...,
  };

  declare export type TSUnionType = BaseNode & {
    type: 'TSUnionType',
    types: TSType[],
    ...,
  };

  declare export type TSIntersectionType = BaseNode & {
    type: 'TSIntersectionType',
    types: TSType[],
    ...,
  };

  declare export type TSConditionalType = BaseNode & {
    checkType: TSType,
    extendsType: TSType,
    falseType: TSType,
    trueType: TSType,
    type: 'TSConditionalType',
    ...,
  };

  declare export type TSInferType = BaseNode & {
    type: 'TSInferType',
    typeParameter: TSTypeParameter,
    ...,
  };

  declare export type TSParenthesizedType = BaseNode & {
    type: 'TSParenthesizedType',
    typeAnnotation: TSType,
    ...,
  };

  declare export type TSTypeOperator = BaseNode & {
    operator: string,
    type: 'TSTypeOperator',
    typeAnnotation: TSType,
    ...,
  };

  declare export type TSIndexedAccessType = BaseNode & {
    indexType: TSType,
    objectType: TSType,
    type: 'TSIndexedAccessType',
    ...,
  };

  declare export type TSMappedType = BaseNode & {
    nameType: TSType | null,
    optional: boolean | null,
    readonly: boolean | null,
    type: 'TSMappedType',
    typeAnnotation: TSType | null,
    typeParameter: TSTypeParameter,
    ...,
  };

  declare export type TSLiteralType = BaseNode & {
    literal: | BigIntLiteral
      | BooleanLiteral
      | NumericLiteral
      | StringLiteral
      | UnaryExpression,
    type: 'TSLiteralType',
    ...,
  };

  declare export type TSExpressionWithTypeArguments = BaseNode & {
    expression: TSEntityName,
    type: 'TSExpressionWithTypeArguments',
    typeParameters: TSTypeParameterInstantiation | null,
    ...,
  };

  declare export type TSInterfaceDeclaration = BaseNode & {
    body: TSInterfaceBody,
    declare: boolean | null,
    extends: TSExpressionWithTypeArguments[] | null,
    id: Identifier,
    type: 'TSInterfaceDeclaration',
    typeParameters: TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSInterfaceBody = BaseNode & {
    body: TSTypeElement[],
    type: 'TSInterfaceBody',
    ...,
  };

  declare export type TSTypeAliasDeclaration = BaseNode & {
    declare: boolean | null,
    id: Identifier,
    type: 'TSTypeAliasDeclaration',
    typeAnnotation: TSType,
    typeParameters: TSTypeParameterDeclaration | null,
    ...,
  };

  declare export type TSAsExpression = BaseNode & {
    expression: Expression,
    type: 'TSAsExpression',
    typeAnnotation: TSType,
    ...,
  };

  declare export type TSTypeAssertion = BaseNode & {
    expression: Expression,
    type: 'TSTypeAssertion',
    typeAnnotation: TSType,
    ...,
  };

  declare export type TSEnumDeclaration = BaseNode & {
    const: boolean | null,
    declare: boolean | null,
    id: Identifier,
    initializer: Expression | null,
    members: TSEnumMember[],
    type: 'TSEnumDeclaration',
    ...,
  };

  declare export type TSEnumMember = BaseNode & {
    id: Identifier | StringLiteral,
    initializer: Expression | null,
    type: 'TSEnumMember',
    ...,
  };

  declare export type TSModuleDeclaration = BaseNode & {
    body: TSModuleBlock | TSModuleDeclaration,
    declare: boolean | null,
    global: boolean | null,
    id: Identifier | StringLiteral,
    type: 'TSModuleDeclaration',
    ...,
  };

  declare export type TSModuleBlock = BaseNode & {
    body: Statement[],
    type: 'TSModuleBlock',
    ...,
  };

  declare export type TSImportType = BaseNode & {
    argument: StringLiteral,
    qualifier: TSEntityName | null,
    type: 'TSImportType',
    typeParameters: TSTypeParameterInstantiation | null,
    ...,
  };

  declare export type TSImportEqualsDeclaration = BaseNode & {
    id: Identifier,
    importKind: 'type' | 'value' | null,
    isExport: boolean,
    moduleReference: TSEntityName | TSExternalModuleReference,
    type: 'TSImportEqualsDeclaration',
    ...,
  };

  declare export type TSExternalModuleReference = BaseNode & {
    expression: StringLiteral,
    type: 'TSExternalModuleReference',
    ...,
  };

  declare export type TSNonNullExpression = BaseNode & {
    expression: Expression,
    type: 'TSNonNullExpression',
    ...,
  };

  declare export type TSExportAssignment = BaseNode & {
    expression: Expression,
    type: 'TSExportAssignment',
    ...,
  };

  declare export type TSNamespaceExportDeclaration = BaseNode & {
    id: Identifier,
    type: 'TSNamespaceExportDeclaration',
    ...,
  };

  declare export type TSTypeAnnotation = BaseNode & {
    type: 'TSTypeAnnotation',
    typeAnnotation: TSType,
    ...,
  };

  declare export type TSTypeParameterInstantiation = BaseNode & {
    params: TSType[],
    type: 'TSTypeParameterInstantiation',
    ...,
  };

  declare export type TSTypeParameterDeclaration = BaseNode & {
    params: TSTypeParameter[],
    type: 'TSTypeParameterDeclaration',
    ...,
  };

  declare export type TSTypeParameter = BaseNode & {
    constraint: TSType | null,
    default: TSType | null,
    name: string,
    type: 'TSTypeParameter',
    ...,
  };

  /**
   * @deprecated Use `NumericLiteral`
   */
  declare export

type NumberLiteral = NumericLiteral;

  /**
   * @deprecated Use `RegExpLiteral`
   */
  declare export

type RegexLiteral = RegExpLiteral;

  /**
   * @deprecated Use `RestElement`
   */
  declare export

type RestProperty = RestElement;

  /**
   * @deprecated Use `SpreadElement`
   */
  declare export

type SpreadProperty = SpreadElement;

  declare export type Standardized =
    | ArrayExpression
    | ArrayPattern
    | ArrowFunctionExpression
    | AssignmentExpression
    | AssignmentPattern
    | AwaitExpression
    | BigIntLiteral
    | BinaryExpression
    | BlockStatement
    | BooleanLiteral
    | BreakStatement
    | CallExpression
    | CatchClause
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | ClassMethod
    | ClassPrivateMethod
    | ClassPrivateProperty
    | ClassProperty
    | ConditionalExpression
    | ContinueStatement
    | DebuggerStatement
    | Directive
    | DirectiveLiteral
    | DoWhileStatement
    | EmptyStatement
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ExportNamespaceSpecifier
    | ExportSpecifier
    | ExpressionStatement
    | File
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Identifier
    | IfStatement
    | Import
    | ImportDeclaration
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | InterpreterDirective
    | LabeledStatement
    | LogicalExpression
    | MemberExpression
    | MetaProperty
    | NewExpression
    | NullLiteral
    | NumericLiteral
    | ObjectExpression
    | ObjectMethod
    | ObjectPattern
    | ObjectProperty
    | OptionalCallExpression
    | OptionalMemberExpression
    | ParenthesizedExpression
    | PrivateName
    | Program
    | RegExpLiteral
    | RestElement
    | ReturnStatement
    | SequenceExpression
    | SpreadElement
    | StaticBlock
    | StringLiteral
    | Super
    | SwitchCase
    | SwitchStatement
    | TaggedTemplateExpression
    | TemplateElement
    | TemplateLiteral
    | ThisExpression
    | ThrowStatement
    | TryStatement
    | UnaryExpression
    | UpdateExpression
    | VariableDeclaration
    | VariableDeclarator
    | WhileStatement
    | WithStatement
    | YieldExpression;

  declare export type Expression =
    | ArrayExpression
    | ArrowFunctionExpression
    | AssignmentExpression
    | AwaitExpression
    | BigIntLiteral
    | BinaryExpression
    | BindExpression
    | BooleanLiteral
    | CallExpression
    | ClassExpression
    | ConditionalExpression
    | DecimalLiteral
    | DoExpression
    | FunctionExpression
    | Identifier
    | Import
    | JSXElement
    | JSXFragment
    | LogicalExpression
    | MemberExpression
    | MetaProperty
    | ModuleExpression
    | NewExpression
    | NullLiteral
    | NumericLiteral
    | ObjectExpression
    | OptionalCallExpression
    | OptionalMemberExpression
    | ParenthesizedExpression
    | PipelineBareFunction
    | PipelinePrimaryTopicReference
    | PipelineTopicExpression
    | RecordExpression
    | RegExpLiteral
    | SequenceExpression
    | StringLiteral
    | Super
    | TaggedTemplateExpression
    | TemplateLiteral
    | ThisExpression
    | TopicReference
    | TSAsExpression
    | TSNonNullExpression
    | TSTypeAssertion
    | TupleExpression
    | TypeCastExpression
    | UnaryExpression
    | UpdateExpression
    | YieldExpression;

  declare export type Binary = BinaryExpression | LogicalExpression;

  declare export type Scopable =
    | ArrowFunctionExpression
    | BlockStatement
    | CatchClause
    | ClassDeclaration
    | ClassExpression
    | ClassMethod
    | ClassPrivateMethod
    | DoWhileStatement
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | Program
    | StaticBlock
    | SwitchStatement
    | TSModuleBlock
    | WhileStatement;

  declare export type BlockParent =
    | ArrowFunctionExpression
    | BlockStatement
    | CatchClause
    | ClassMethod
    | ClassPrivateMethod
    | DoWhileStatement
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | Program
    | StaticBlock
    | SwitchStatement
    | TSModuleBlock
    | WhileStatement;

  declare export type Block = BlockStatement | Program | TSModuleBlock;

  declare export type Statement =
    | BlockStatement
    | BreakStatement
    | ClassDeclaration
    | ContinueStatement
    | DebuggerStatement
    | DeclareClass
    | DeclareExportAllDeclaration
    | DeclareExportDeclaration
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareOpaqueType
    | DeclareTypeAlias
    | DeclareVariable
    | DoWhileStatement
    | EmptyStatement
    | EnumDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ExpressionStatement
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | FunctionDeclaration
    | IfStatement
    | ImportDeclaration
    | InterfaceDeclaration
    | LabeledStatement
    | OpaqueType
    | ReturnStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | TSDeclareFunction
    | TSEnumDeclaration
    | TSExportAssignment
    | TSImportEqualsDeclaration
    | TSInterfaceDeclaration
    | TSModuleDeclaration
    | TSNamespaceExportDeclaration
    | TSTypeAliasDeclaration
    | TypeAlias
    | VariableDeclaration
    | WhileStatement
    | WithStatement;

  declare export type Terminatorless =
    | AwaitExpression
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement
    | YieldExpression;

  declare export type CompletionStatement =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement;

  declare export type Conditional = ConditionalExpression | IfStatement;

  declare export type Loop =
    | DoWhileStatement
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | WhileStatement;

  declare export type While = DoWhileStatement | WhileStatement;

  declare export type ExpressionWrapper =
    | ExpressionStatement
    | ParenthesizedExpression
    | TypeCastExpression;

  declare export type For = ForInStatement | ForOfStatement | ForStatement;

  declare export type ForXStatement = ForInStatement | ForOfStatement;

  declare export type IFunction =
    | ArrowFunctionExpression
    | ClassMethod
    | ClassPrivateMethod
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod;

  declare export type FunctionParent =
    | ArrowFunctionExpression
    | ClassMethod
    | ClassPrivateMethod
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | StaticBlock;

  declare export type Pureish =
    | ArrowFunctionExpression
    | BigIntLiteral
    | BooleanLiteral
    | DecimalLiteral
    | FunctionDeclaration
    | FunctionExpression
    | NullLiteral
    | NumericLiteral
    | RegExpLiteral
    | StringLiteral;

  declare export type Declaration =
    | ClassDeclaration
    | DeclareClass
    | DeclareExportAllDeclaration
    | DeclareExportDeclaration
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareOpaqueType
    | DeclareTypeAlias
    | DeclareVariable
    | EnumDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | FunctionDeclaration
    | ImportDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TSDeclareFunction
    | TSEnumDeclaration
    | TSInterfaceDeclaration
    | TSModuleDeclaration
    | TSTypeAliasDeclaration
    | TypeAlias
    | VariableDeclaration;

  declare export type PatternLike =
    | ArrayPattern
    | AssignmentPattern
    | Identifier
    | ObjectPattern
    | RestElement;

  declare export type LVal =
    | ArrayPattern
    | AssignmentPattern
    | Identifier
    | MemberExpression
    | ObjectPattern
    | RestElement
    | TSParameterProperty;

  declare export type TSEntityName = Identifier | TSQualifiedName;

  declare export type Literal =
    | BigIntLiteral
    | BooleanLiteral
    | DecimalLiteral
    | NullLiteral
    | NumericLiteral
    | RegExpLiteral
    | StringLiteral
    | TemplateLiteral;

  declare export type Immutable =
    | BigIntLiteral
    | BooleanLiteral
    | DecimalLiteral
    | JSXAttribute
    | JSXClosingElement
    | JSXClosingFragment
    | JSXElement
    | JSXExpressionContainer
    | JSXFragment
    | JSXOpeningElement
    | JSXOpeningFragment
    | JSXSpreadChild
    | JSXText
    | NullLiteral
    | NumericLiteral
    | StringLiteral;

  declare export type UserWhitespacable =
    | ObjectMethod
    | ObjectProperty
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeInternalSlot
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty;

  declare export type Method = ClassMethod | ClassPrivateMethod | ObjectMethod;

  declare export type ObjectMember = ObjectMethod | ObjectProperty;

  declare export type Property =
    | ClassPrivateProperty
    | ClassProperty
    | ObjectProperty;

  declare export type UnaryLike = SpreadElement | UnaryExpression;

  declare export type Pattern =
    | ArrayPattern
    | AssignmentPattern
    | ObjectPattern;

  declare export type IClass = ClassDeclaration | ClassExpression;

  declare export type ModuleDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration;

  declare export type ExportDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration;

  declare export type ModuleSpecifier =
    | ExportDefaultSpecifier
    | ExportNamespaceSpecifier
    | ExportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier;

  declare export type Private =
    | ClassPrivateMethod
    | ClassPrivateProperty
    | PrivateName;

  declare export type Flow =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | ClassImplements
    | DeclareClass
    | DeclaredPredicate
    | DeclareExportAllDeclaration
    | DeclareExportDeclaration
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareOpaqueType
    | DeclareTypeAlias
    | DeclareVariable
    | EmptyTypeAnnotation
    | EnumBooleanBody
    | EnumBooleanMember
    | EnumDeclaration
    | EnumDefaultedMember
    | EnumNumberBody
    | EnumNumberMember
    | EnumStringBody
    | EnumStringMember
    | EnumSymbolBody
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | IndexedAccessType
    | InferredPredicate
    | InterfaceDeclaration
    | InterfaceExtends
    | InterfaceTypeAnnotation
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | NullableTypeAnnotation
    | NullLiteralTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeInternalSlot
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | OptionalIndexedAccessType
    | QualifiedTypeIdentifier
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | SymbolTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeofTypeAnnotation
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | UnionTypeAnnotation
    | Variance
    | VoidTypeAnnotation;

  declare export type FlowType =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | EmptyTypeAnnotation
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | GenericTypeAnnotation
    | IndexedAccessType
    | InterfaceTypeAnnotation
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | NullableTypeAnnotation
    | NullLiteralTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | OptionalIndexedAccessType
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | SymbolTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | UnionTypeAnnotation
    | VoidTypeAnnotation;

  declare export type FlowBaseAnnotation =
    | AnyTypeAnnotation
    | BooleanTypeAnnotation
    | EmptyTypeAnnotation
    | MixedTypeAnnotation
    | NullLiteralTypeAnnotation
    | NumberTypeAnnotation
    | StringTypeAnnotation
    | SymbolTypeAnnotation
    | ThisTypeAnnotation
    | VoidTypeAnnotation;

  declare export type FlowDeclaration =
    | DeclareClass
    | DeclareExportAllDeclaration
    | DeclareExportDeclaration
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareOpaqueType
    | DeclareTypeAlias
    | DeclareVariable
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias;

  declare export type FlowPredicate = DeclaredPredicate | InferredPredicate;

  declare export type EnumBody =
    | EnumBooleanBody
    | EnumNumberBody
    | EnumStringBody
    | EnumSymbolBody;

  declare export type EnumMember =
    | EnumBooleanMember
    | EnumDefaultedMember
    | EnumNumberMember
    | EnumStringMember;

  declare export type JSX =
    | JSXAttribute
    | JSXClosingElement
    | JSXClosingFragment
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXFragment
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXOpeningFragment
    | JSXSpreadAttribute
    | JSXSpreadChild
    | JSXText;

  declare export type Miscellaneous =
    | Noop
    | Placeholder
    | V8IntrinsicIdentifier;

  declare export type TypeScript =
    | TSAnyKeyword
    | TSArrayType
    | TSAsExpression
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSCallSignatureDeclaration
    | TSConditionalType
    | TSConstructorType
    | TSConstructSignatureDeclaration
    | TSDeclareFunction
    | TSDeclareMethod
    | TSEnumDeclaration
    | TSEnumMember
    | TSExportAssignment
    | TSExpressionWithTypeArguments
    | TSExternalModuleReference
    | TSFunctionType
    | TSImportEqualsDeclaration
    | TSImportType
    | TSIndexedAccessType
    | TSIndexSignature
    | TSInferType
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSIntersectionType
    | TSIntrinsicKeyword
    | TSLiteralType
    | TSMappedType
    | TSMethodSignature
    | TSModuleBlock
    | TSModuleDeclaration
    | TSNamedTupleMember
    | TSNamespaceExportDeclaration
    | TSNeverKeyword
    | TSNonNullExpression
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSOptionalType
    | TSParameterProperty
    | TSParenthesizedType
    | TSPropertySignature
    | TSQualifiedName
    | TSRestType
    | TSStringKeyword
    | TSSymbolKeyword
    | TSThisType
    | TSTupleType
    | TSTypeAliasDeclaration
    | TSTypeAnnotation
    | TSTypeAssertion
    | TSTypeLiteral
    | TSTypeOperator
    | TSTypeParameter
    | TSTypeParameterDeclaration
    | TSTypeParameterInstantiation
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeReference
    | TSUndefinedKeyword
    | TSUnionType
    | TSUnknownKeyword
    | TSVoidKeyword;

  declare export type TSTypeElement =
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSIndexSignature
    | TSMethodSignature
    | TSPropertySignature;

  declare export type TSType =
    | TSAnyKeyword
    | TSArrayType
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSConditionalType
    | TSConstructorType
    | TSExpressionWithTypeArguments
    | TSFunctionType
    | TSImportType
    | TSIndexedAccessType
    | TSInferType
    | TSIntersectionType
    | TSIntrinsicKeyword
    | TSLiteralType
    | TSMappedType
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSOptionalType
    | TSParenthesizedType
    | TSRestType
    | TSStringKeyword
    | TSSymbolKeyword
    | TSThisType
    | TSTupleType
    | TSTypeLiteral
    | TSTypeOperator
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeReference
    | TSUndefinedKeyword
    | TSUnionType
    | TSUnknownKeyword
    | TSVoidKeyword;

  declare export type TSBaseType =
    | TSAnyKeyword
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSIntrinsicKeyword
    | TSLiteralType
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSThisType
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword;

  declare export interface Aliases {
    Binary: Binary,
    Block: Block,
    BlockParent: BlockParent,
    Class: IClass,
    CompletionStatement: CompletionStatement,
    Conditional: Conditional,
    Declaration: Declaration,
    EnumBody: EnumBody,
    EnumMember: EnumMember,
    exportDeclaration: ExportDeclaration,
    Expression: Expression,
    ExpressionWrapper: ExpressionWrapper,
    Flow: Flow,
    FlowBaseAnnotation: FlowBaseAnnotation,
    FlowDeclaration: FlowDeclaration,
    FlowPredicate: FlowPredicate,
    FlowType: FlowType,
    For: For,
    ForXStatement: ForXStatement,
    Function: IFunction,
    FunctionParent: FunctionParent,
    Immutable: Immutable,
    JSX: JSX,
    Literal: Literal,
    Loop: Loop,
    LVal: LVal,
    Method: Method,
    Miscellaneous: Miscellaneous,
    ModuleDeclaration: ModuleDeclaration,
    ModuleSpecifier: ModuleSpecifier,
    ObjectMember: ObjectMember,
    Pattern: Pattern,
    PatternLike: PatternLike,
    Private: Private,
    Property: Property,
    Pureish: Pureish,
    Scopable: Scopable,
    Standardized: Standardized,
    Statement: Statement,
    Terminatorless: Terminatorless,
    TSBaseType: TSBaseType,
    TSEntityName: TSEntityName,
    TSType: TSType,
    TSTypeElement: TSTypeElement,
    TypeScript: TypeScript,
    UnaryLike: UnaryLike,
    UserWhitespacable: UserWhitespacable,
    While: While,
  }
  declare export function arrayExpression(
    elements?: Array<Expression | SpreadElement | null>
  ): ArrayExpression;
  declare export function assignmentExpression(
    operator: string,
    left: LVal,
    right: Expression
  ): AssignmentExpression;
  declare export function binaryExpression(
    operator: | '-'
      | '!='
      | '!=='
      | '*'
      | '**'
      | '/'
      | '&'
      | '%'
      | '^'
      | '+'
      | '<'
      | '<<'
      | '<='
      | '=='
      | '==='
      | '>'
      | '>='
      | '>>'
      | '>>>'
      | '|'
      | 'in'
      | 'instanceof',
    left: Expression | PrivateName,
    right: Expression
  ): BinaryExpression;
  declare export function interpreterDirective(
    value: string
  ): InterpreterDirective;
  declare export function directive(value: DirectiveLiteral): Directive;
  declare export function directiveLiteral(value: string): DirectiveLiteral;
  declare export function blockStatement(
    body: Statement[],
    directives?: Directive[]
  ): BlockStatement;
  declare export function breakStatement(
    label?: Identifier | null
  ): BreakStatement;
  declare export function callExpression(
    callee: Expression | V8IntrinsicIdentifier,
    _arguments: Array<
      ArgumentPlaceholder | Expression | JSXNamespacedName | SpreadElement>
  ): CallExpression;
  declare export function catchClause(
    param: ArrayPattern | Identifier | ObjectPattern | null | void,
    body: BlockStatement
  ): CatchClause;
  declare export function conditionalExpression(
    test: Expression,
    consequent: Expression,
    alternate: Expression
  ): ConditionalExpression;
  declare export function continueStatement(
    label?: Identifier | null
  ): ContinueStatement;
  declare export function debuggerStatement(): DebuggerStatement;
  declare export function doWhileStatement(
    test: Expression,
    body: Statement
  ): DoWhileStatement;
  declare export function emptyStatement(): EmptyStatement;
  declare export function expressionStatement(
    expression: Expression
  ): ExpressionStatement;
  declare export function file(
    program: Program,
    comments?: Array<CommentBlock | CommentLine> | null,
    tokens?: mixed[] | null
  ): File;
  declare export function forInStatement(
    left: LVal | VariableDeclaration,
    right: Expression,
    body: Statement
  ): ForInStatement;
  declare export function forStatement(
    init: Expression | VariableDeclaration | null | void,
    test: Expression | null | void,
    update: Expression | null | void,
    body: Statement
  ): ForStatement;
  declare export function functionDeclaration(
    id: Identifier | null | void,
    params: Array<Identifier | Pattern | RestElement>,
    body: BlockStatement,
    generator?: boolean,
    async?: boolean
  ): FunctionDeclaration;
  declare export function functionExpression(
    id: Identifier | null | void,
    params: Array<Identifier | Pattern | RestElement>,
    body: BlockStatement,
    generator?: boolean,
    async?: boolean
  ): FunctionExpression;
  declare export function identifier(name: string): Identifier;
  declare export function ifStatement(
    test: Expression,
    consequent: Statement,
    alternate?: Statement | null
  ): IfStatement;
  declare export function labeledStatement(
    label: Identifier,
    body: Statement
  ): LabeledStatement;
  declare export function stringLiteral(value: string): StringLiteral;
  declare export function numericLiteral(value: number): NumericLiteral;
  declare export function nullLiteral(): NullLiteral;
  declare export function booleanLiteral(value: boolean): BooleanLiteral;
  declare export function regExpLiteral(
    pattern: string,
    flags?: string
  ): RegExpLiteral;
  declare export function logicalExpression(
    operator: '??' | '&&' | '||',
    left: Expression,
    right: Expression
  ): LogicalExpression;
  declare export function memberExpression(
    object: Expression,
    property: Expression | Identifier | PrivateName,
    computed?: boolean,
    optional?: false | true | null
  ): MemberExpression;
  declare export function newExpression(
    callee: Expression | V8IntrinsicIdentifier,
    _arguments: Array<
      ArgumentPlaceholder | Expression | JSXNamespacedName | SpreadElement>
  ): NewExpression;
  declare export function program(
    body: Statement[],
    directives?: Directive[],
    sourceType?: 'module' | 'script',
    interpreter?: InterpreterDirective | null
  ): Program;
  declare export function objectExpression(
    properties: Array<ObjectMethod | ObjectProperty | SpreadElement>
  ): ObjectExpression;
  declare export function objectMethod(
    kind: 'get' | 'method' | 'set' | void,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    params: Array<Identifier | Pattern | RestElement>,
    body: BlockStatement,
    computed?: boolean,
    generator?: boolean,
    async?: boolean
  ): ObjectMethod;
  declare export function objectProperty(
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    value: Expression | PatternLike,
    computed?: boolean,
    shorthand?: boolean,
    decorators?: Decorator[] | null
  ): ObjectProperty;
  declare export function restElement(argument: LVal): RestElement;
  declare export function returnStatement(
    argument?: Expression | null
  ): ReturnStatement;
  declare export function sequenceExpression(
    expressions: Expression[]
  ): SequenceExpression;
  declare export function parenthesizedExpression(
    expression: Expression
  ): ParenthesizedExpression;
  declare export function switchCase(
    test: Expression | null | void,
    consequent: Statement[]
  ): SwitchCase;
  declare export function switchStatement(
    discriminant: Expression,
    cases: SwitchCase[]
  ): SwitchStatement;
  declare export function thisExpression(): ThisExpression;
  declare export function throwStatement(argument: Expression): ThrowStatement;
  declare export function tryStatement(
    block: BlockStatement,
    handler?: CatchClause | null,
    finalizer?: BlockStatement | null
  ): TryStatement;
  declare export function unaryExpression(
    operator: '-' | '!' | '+' | '~' | 'delete' | 'throw' | 'typeof' | 'void',
    argument: Expression,
    prefix?: boolean
  ): UnaryExpression;
  declare export function updateExpression(
    operator: '--' | '++',
    argument: Expression,
    prefix?: boolean
  ): UpdateExpression;
  declare export function variableDeclaration(
    kind: 'const' | 'let' | 'var',
    declarations: VariableDeclarator[]
  ): VariableDeclaration;
  declare export function variableDeclarator(
    id: LVal,
    init?: Expression | null
  ): VariableDeclarator;
  declare export function whileStatement(
    test: Expression,
    body: Statement
  ): WhileStatement;
  declare export function withStatement(
    object: Expression,
    body: Statement
  ): WithStatement;
  declare export function assignmentPattern(
    left: ArrayPattern | Identifier | MemberExpression | ObjectPattern,
    right: Expression
  ): AssignmentPattern;
  declare export function arrayPattern(
    elements: Array<PatternLike | null>
  ): ArrayPattern;
  declare export function arrowFunctionExpression(
    params: Array<Identifier | Pattern | RestElement>,
    body: BlockStatement | Expression,
    async?: boolean
  ): ArrowFunctionExpression;
  declare export function classBody(
    body: Array<
      | ClassMethod
      | ClassPrivateMethod
      | ClassPrivateProperty
      | ClassProperty
      | TSDeclareMethod
      | TSIndexSignature>
  ): ClassBody;
  declare export function classExpression(
    id: Identifier | null | void,
    superClass: Expression | null | void,
    body: ClassBody,
    decorators?: Decorator[] | null
  ): ClassExpression;
  declare export function classDeclaration(
    id: Identifier,
    superClass: Expression | null | void,
    body: ClassBody,
    decorators?: Decorator[] | null
  ): ClassDeclaration;
  declare export function exportAllDeclaration(
    source: StringLiteral
  ): ExportAllDeclaration;
  declare export function exportDefaultDeclaration(
    declaration: | ClassDeclaration
      | Expression
      | FunctionDeclaration
      | TSDeclareFunction
  ): ExportDefaultDeclaration;
  declare export function exportNamedDeclaration(
    declaration?: Declaration | null,
    specifiers?: Array<
      ExportDefaultSpecifier | ExportNamespaceSpecifier | ExportSpecifier>,
    source?: StringLiteral | null
  ): ExportNamedDeclaration;
  declare export function exportSpecifier(
    local: Identifier,
    exported: Identifier | StringLiteral
  ): ExportSpecifier;
  declare export function forOfStatement(
    left: LVal | VariableDeclaration,
    right: Expression,
    body: Statement,
    _await?: boolean
  ): ForOfStatement;
  declare export function importDeclaration(
    specifiers: Array<
      ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier>,
    source: StringLiteral
  ): ImportDeclaration;
  declare export function importDefaultSpecifier(
    local: Identifier
  ): ImportDefaultSpecifier;
  declare export function importNamespaceSpecifier(
    local: Identifier
  ): ImportNamespaceSpecifier;
  declare export function importSpecifier(
    local: Identifier,
    imported: Identifier | StringLiteral
  ): ImportSpecifier;
  declare export function metaProperty(
    meta: Identifier,
    property: Identifier
  ): MetaProperty;
  declare export function classMethod(
    kind: 'constructor' | 'get' | 'method' | 'set' | void,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
    body: BlockStatement,
    computed?: boolean,
    _static?: boolean,
    generator?: boolean,
    async?: boolean
  ): ClassMethod;
  declare export function objectPattern(
    properties: Array<ObjectProperty | RestElement>
  ): ObjectPattern;
  declare export function spreadElement(argument: Expression): SpreadElement;
  declare function _super(): Super;
  // declare export {
  //           _super as super
  //         }
  declare export function taggedTemplateExpression(
    tag: Expression,
    quasi: TemplateLiteral
  ): TaggedTemplateExpression;
  declare export function templateElement(
    value: {
      cooked?: string,
      raw: string,
      ...,
    },
    tail?: boolean
  ): TemplateElement;
  declare export function templateLiteral(
    quasis: TemplateElement[],
    expressions: Array<Expression | TSType>
  ): TemplateLiteral;
  declare export function yieldExpression(
    argument?: Expression | null,
    delegate?: boolean
  ): YieldExpression;
  declare export function awaitExpression(
    argument: Expression
  ): AwaitExpression;
  declare function _import(): Import;
  // declare export {
  //           _import as import
  //         }
  declare export function bigIntLiteral(value: string): BigIntLiteral;
  declare export function exportNamespaceSpecifier(
    exported: Identifier
  ): ExportNamespaceSpecifier;
  declare export function optionalMemberExpression(
    object: Expression,
    property: Expression | Identifier,
    computed: boolean | void,
    optional: boolean
  ): OptionalMemberExpression;
  declare export function optionalCallExpression(
    callee: Expression,
    _arguments: Array<
      ArgumentPlaceholder | Expression | JSXNamespacedName | SpreadElement>,
    optional: boolean
  ): OptionalCallExpression;
  declare export function classProperty(
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    value?: Expression | null,
    typeAnnotation?: Noop | TSTypeAnnotation | TypeAnnotation | null,
    decorators?: Decorator[] | null,
    computed?: boolean,
    _static?: boolean
  ): ClassProperty;
  declare export function classPrivateProperty(
    key: PrivateName,
    value: Expression | null | void,
    decorators: Decorator[] | null | void,
    _static: mixed
  ): ClassPrivateProperty;
  declare export function classPrivateMethod(
    kind: 'constructor' | 'get' | 'method' | 'set' | void,
    key: PrivateName,
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
    body: BlockStatement,
    _static?: boolean
  ): ClassPrivateMethod;
  declare export function privateName(id: Identifier): PrivateName;
  declare export function staticBlock(body: Statement[]): StaticBlock;
  declare export function anyTypeAnnotation(): AnyTypeAnnotation;
  declare export function arrayTypeAnnotation(
    elementType: FlowType
  ): ArrayTypeAnnotation;
  declare export function booleanTypeAnnotation(): BooleanTypeAnnotation;
  declare export function booleanLiteralTypeAnnotation(
    value: boolean
  ): BooleanLiteralTypeAnnotation;
  declare export function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;
  declare export function classImplements(
    id: Identifier,
    typeParameters?: TypeParameterInstantiation | null
  ): ClassImplements;
  declare export function declareClass(
    id: Identifier,
    typeParameters: TypeParameterDeclaration | null | void,
    _extends: InterfaceExtends[] | null | void,
    body: ObjectTypeAnnotation
  ): DeclareClass;
  declare export function declareFunction(id: Identifier): DeclareFunction;
  declare export function declareInterface(
    id: Identifier,
    typeParameters: TypeParameterDeclaration | null | void,
    _extends: InterfaceExtends[] | null | void,
    body: ObjectTypeAnnotation
  ): DeclareInterface;
  declare export function declareModule(
    id: Identifier | StringLiteral,
    body: BlockStatement,
    kind?: 'CommonJS' | 'ES' | null
  ): DeclareModule;
  declare export function declareModuleExports(
    typeAnnotation: TypeAnnotation
  ): DeclareModuleExports;
  declare export function declareTypeAlias(
    id: Identifier,
    typeParameters: TypeParameterDeclaration | null | void,
    right: FlowType
  ): DeclareTypeAlias;
  declare export function declareOpaqueType(
    id: Identifier,
    typeParameters?: TypeParameterDeclaration | null,
    supertype?: FlowType | null
  ): DeclareOpaqueType;
  declare export function declareVariable(id: Identifier): DeclareVariable;
  declare export function declareExportDeclaration(
    declaration?: Flow | null,
    specifiers?: Array<ExportNamespaceSpecifier | ExportSpecifier> | null,
    source?: StringLiteral | null
  ): DeclareExportDeclaration;
  declare export function declareExportAllDeclaration(
    source: StringLiteral
  ): DeclareExportAllDeclaration;
  declare export function declaredPredicate(value: Flow): DeclaredPredicate;
  declare export function existsTypeAnnotation(): ExistsTypeAnnotation;
  declare export function functionTypeAnnotation(
    typeParameters: TypeParameterDeclaration | null | void,
    params: FunctionTypeParam[],
    rest: FunctionTypeParam | null | void,
    returnType: FlowType
  ): FunctionTypeAnnotation;
  declare export function functionTypeParam(
    name: Identifier | null | void,
    typeAnnotation: FlowType
  ): FunctionTypeParam;
  declare export function genericTypeAnnotation(
    id: Identifier | QualifiedTypeIdentifier,
    typeParameters?: TypeParameterInstantiation | null
  ): GenericTypeAnnotation;
  declare export function inferredPredicate(): InferredPredicate;
  declare export function interfaceExtends(
    id: Identifier | QualifiedTypeIdentifier,
    typeParameters?: TypeParameterInstantiation | null
  ): InterfaceExtends;
  declare export function interfaceDeclaration(
    id: Identifier,
    typeParameters: TypeParameterDeclaration | null | void,
    _extends: InterfaceExtends[] | null | void,
    body: ObjectTypeAnnotation
  ): InterfaceDeclaration;
  declare export function interfaceTypeAnnotation(
    _extends: InterfaceExtends[] | null | void,
    body: ObjectTypeAnnotation
  ): InterfaceTypeAnnotation;
  declare export function intersectionTypeAnnotation(
    types: FlowType[]
  ): IntersectionTypeAnnotation;
  declare export function mixedTypeAnnotation(): MixedTypeAnnotation;
  declare export function emptyTypeAnnotation(): EmptyTypeAnnotation;
  declare export function nullableTypeAnnotation(
    typeAnnotation: FlowType
  ): NullableTypeAnnotation;
  declare export function numberLiteralTypeAnnotation(
    value: number
  ): NumberLiteralTypeAnnotation;
  declare export function numberTypeAnnotation(): NumberTypeAnnotation;
  declare export function objectTypeAnnotation(
    properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>,
    indexers?: ObjectTypeIndexer[] | null,
    callProperties?: ObjectTypeCallProperty[] | null,
    internalSlots?: ObjectTypeInternalSlot[] | null,
    exact?: boolean
  ): ObjectTypeAnnotation;
  declare export function objectTypeInternalSlot(
    id: Identifier,
    value: FlowType,
    optional: boolean,
    _static: boolean,
    method: boolean
  ): ObjectTypeInternalSlot;
  declare export function objectTypeCallProperty(
    value: FlowType
  ): ObjectTypeCallProperty;
  declare export function objectTypeIndexer(
    id: Identifier | null | void,
    key: FlowType,
    value: FlowType,
    variance?: Variance | null
  ): ObjectTypeIndexer;
  declare export function objectTypeProperty(
    key: Identifier | StringLiteral,
    value: FlowType,
    variance?: Variance | null
  ): ObjectTypeProperty;
  declare export function objectTypeSpreadProperty(
    argument: FlowType
  ): ObjectTypeSpreadProperty;
  declare export function opaqueType(
    id: Identifier,
    typeParameters: TypeParameterDeclaration | null | void,
    supertype: FlowType | null | void,
    impltype: FlowType
  ): OpaqueType;
  declare export function qualifiedTypeIdentifier(
    id: Identifier,
    qualification: Identifier | QualifiedTypeIdentifier
  ): QualifiedTypeIdentifier;
  declare export function stringLiteralTypeAnnotation(
    value: string
  ): StringLiteralTypeAnnotation;
  declare export function stringTypeAnnotation(): StringTypeAnnotation;
  declare export function symbolTypeAnnotation(): SymbolTypeAnnotation;
  declare export function thisTypeAnnotation(): ThisTypeAnnotation;
  declare export function tupleTypeAnnotation(
    types: FlowType[]
  ): TupleTypeAnnotation;
  declare export function typeofTypeAnnotation(
    argument: FlowType
  ): TypeofTypeAnnotation;
  declare export function typeAlias(
    id: Identifier,
    typeParameters: TypeParameterDeclaration | null | void,
    right: FlowType
  ): TypeAlias;
  declare export function typeAnnotation(
    typeAnnotation: FlowType
  ): TypeAnnotation;
  declare export function typeCastExpression(
    expression: Expression,
    typeAnnotation: TypeAnnotation
  ): TypeCastExpression;
  declare export function typeParameter(
    bound?: TypeAnnotation | null,
    _default?: FlowType | null,
    variance?: Variance | null
  ): TypeParameter;
  declare export function typeParameterDeclaration(
    params: TypeParameter[]
  ): TypeParameterDeclaration;
  declare export function typeParameterInstantiation(
    params: FlowType[]
  ): TypeParameterInstantiation;
  declare export function unionTypeAnnotation(
    types: FlowType[]
  ): UnionTypeAnnotation;
  declare export function variance(kind: 'minus' | 'plus'): Variance;
  declare export function voidTypeAnnotation(): VoidTypeAnnotation;
  declare export function enumDeclaration(
    id: Identifier,
    body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody
  ): EnumDeclaration;
  declare export function enumBooleanBody(
    members: EnumBooleanMember[]
  ): EnumBooleanBody;
  declare export function enumNumberBody(
    members: EnumNumberMember[]
  ): EnumNumberBody;
  declare export function enumStringBody(
    members: Array<EnumDefaultedMember | EnumStringMember>
  ): EnumStringBody;
  declare export function enumSymbolBody(
    members: EnumDefaultedMember[]
  ): EnumSymbolBody;
  declare export function enumBooleanMember(id: Identifier): EnumBooleanMember;
  declare export function enumNumberMember(
    id: Identifier,
    init: NumericLiteral
  ): EnumNumberMember;
  declare export function enumStringMember(
    id: Identifier,
    init: StringLiteral
  ): EnumStringMember;
  declare export function enumDefaultedMember(
    id: Identifier
  ): EnumDefaultedMember;
  declare export function indexedAccessType(
    objectType: FlowType,
    indexType: FlowType
  ): IndexedAccessType;
  declare export function optionalIndexedAccessType(
    objectType: FlowType,
    indexType: FlowType
  ): OptionalIndexedAccessType;
  declare export function jsxAttribute(
    name: JSXIdentifier | JSXNamespacedName,
    value?: | JSXElement
      | JSXExpressionContainer
      | JSXFragment
      | StringLiteral
      | null
  ): JSXAttribute;
  declare export function jsxClosingElement(
    name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName
  ): JSXClosingElement;
  declare export function jsxElement(
    openingElement: JSXOpeningElement,
    closingElement: JSXClosingElement | null | void,
    children: Array<
      | JSXElement
      | JSXExpressionContainer
      | JSXFragment
      | JSXSpreadChild
      | JSXText>,
    selfClosing?: boolean | null
  ): JSXElement;
  declare export function jsxEmptyExpression(): JSXEmptyExpression;
  declare export function jsxExpressionContainer(
    expression: Expression | JSXEmptyExpression
  ): JSXExpressionContainer;
  declare export function jsxSpreadChild(
    expression: Expression
  ): JSXSpreadChild;
  declare export function jsxIdentifier(name: string): JSXIdentifier;
  declare export function jsxMemberExpression(
    object: JSXIdentifier | JSXMemberExpression,
    property: JSXIdentifier
  ): JSXMemberExpression;
  declare export function jsxNamespacedName(
    namespace: JSXIdentifier,
    name: JSXIdentifier
  ): JSXNamespacedName;
  declare export function jsxOpeningElement(
    name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName,
    attributes: Array<JSXAttribute | JSXSpreadAttribute>,
    selfClosing?: boolean
  ): JSXOpeningElement;
  declare export function jsxSpreadAttribute(
    argument: Expression
  ): JSXSpreadAttribute;
  declare export function jsxText(value: string): JSXText;
  declare export function jsxFragment(
    openingFragment: JSXOpeningFragment,
    closingFragment: JSXClosingFragment,
    children: Array<
      | JSXElement
      | JSXExpressionContainer
      | JSXFragment
      | JSXSpreadChild
      | JSXText>
  ): JSXFragment;
  declare export function jsxOpeningFragment(): JSXOpeningFragment;
  declare export function jsxClosingFragment(): JSXClosingFragment;
  declare export function noop(): Noop;
  declare export function placeholder(
    expectedNode: | 'BlockStatement'
      | 'ClassBody'
      | 'Declaration'
      | 'Expression'
      | 'Identifier'
      | 'Pattern'
      | 'Statement'
      | 'StringLiteral',
    name: Identifier
  ): Placeholder;
  declare export function v8IntrinsicIdentifier(
    name: string
  ): V8IntrinsicIdentifier;
  declare export function argumentPlaceholder(): ArgumentPlaceholder;
  declare export function bindExpression(
    object: Expression,
    callee: Expression
  ): BindExpression;
  declare export function importAttribute(
    key: Identifier | StringLiteral,
    value: StringLiteral
  ): ImportAttribute;
  declare export function decorator(expression: Expression): Decorator;
  declare export function doExpression(
    body: BlockStatement,
    async?: boolean
  ): DoExpression;
  declare export function exportDefaultSpecifier(
    exported: Identifier
  ): ExportDefaultSpecifier;
  declare export function recordExpression(
    properties: Array<ObjectProperty | SpreadElement>
  ): RecordExpression;
  declare export function tupleExpression(
    elements?: Array<Expression | SpreadElement>
  ): TupleExpression;
  declare export function decimalLiteral(value: string): DecimalLiteral;
  declare export function moduleExpression(body: Program): ModuleExpression;
  declare export function topicReference(): TopicReference;
  declare export function pipelineTopicExpression(
    expression: Expression
  ): PipelineTopicExpression;
  declare export function pipelineBareFunction(
    callee: Expression
  ): PipelineBareFunction;
  declare export function pipelinePrimaryTopicReference(): PipelinePrimaryTopicReference;
  declare export function tsParameterProperty(
    parameter: AssignmentPattern | Identifier
  ): TSParameterProperty;
  declare export function tsDeclareFunction(
    id: Identifier | null | void,
    typeParameters: Noop | TSTypeParameterDeclaration | null | void,
    params: Array<Identifier | Pattern | RestElement>,
    returnType?: Noop | TSTypeAnnotation | null
  ): TSDeclareFunction;
  declare export function tsDeclareMethod(
    decorators: Decorator[] | null | void,
    key: Expression | Identifier | NumericLiteral | StringLiteral,
    typeParameters: Noop | TSTypeParameterDeclaration | null | void,
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>,
    returnType?: Noop | TSTypeAnnotation | null
  ): TSDeclareMethod;
  declare export function tsQualifiedName(
    left: TSEntityName,
    right: Identifier
  ): TSQualifiedName;
  declare export function tsCallSignatureDeclaration(
    typeParameters: TSTypeParameterDeclaration | null | void,
    parameters: Array<Identifier | RestElement>,
    typeAnnotation?: TSTypeAnnotation | null
  ): TSCallSignatureDeclaration;
  declare export function tsConstructSignatureDeclaration(
    typeParameters: TSTypeParameterDeclaration | null | void,
    parameters: Array<Identifier | RestElement>,
    typeAnnotation?: TSTypeAnnotation | null
  ): TSConstructSignatureDeclaration;
  declare export function tsPropertySignature(
    key: Expression,
    typeAnnotation?: TSTypeAnnotation | null,
    initializer?: Expression | null
  ): TSPropertySignature;
  declare export function tsMethodSignature(
    key: Expression,
    typeParameters: TSTypeParameterDeclaration | null | void,
    parameters: Array<Identifier | RestElement>,
    typeAnnotation?: TSTypeAnnotation | null
  ): TSMethodSignature;
  declare export function tsIndexSignature(
    parameters: Identifier[],
    typeAnnotation?: TSTypeAnnotation | null
  ): TSIndexSignature;
  declare export function tsAnyKeyword(): TSAnyKeyword;
  declare export function tsBooleanKeyword(): TSBooleanKeyword;
  declare export function tsBigIntKeyword(): TSBigIntKeyword;
  declare export function tsIntrinsicKeyword(): TSIntrinsicKeyword;
  declare export function tsNeverKeyword(): TSNeverKeyword;
  declare export function tsNullKeyword(): TSNullKeyword;
  declare export function tsNumberKeyword(): TSNumberKeyword;
  declare export function tsObjectKeyword(): TSObjectKeyword;
  declare export function tsStringKeyword(): TSStringKeyword;
  declare export function tsSymbolKeyword(): TSSymbolKeyword;
  declare export function tsUndefinedKeyword(): TSUndefinedKeyword;
  declare export function tsUnknownKeyword(): TSUnknownKeyword;
  declare export function tsVoidKeyword(): TSVoidKeyword;
  declare export function tsThisType(): TSThisType;
  declare export function tsFunctionType(
    typeParameters: TSTypeParameterDeclaration | null | void,
    parameters: Array<Identifier | RestElement>,
    typeAnnotation?: TSTypeAnnotation | null
  ): TSFunctionType;
  declare export function tsConstructorType(
    typeParameters: TSTypeParameterDeclaration | null | void,
    parameters: Array<Identifier | RestElement>,
    typeAnnotation?: TSTypeAnnotation | null
  ): TSConstructorType;
  declare export function tsTypeReference(
    typeName: TSEntityName,
    typeParameters?: TSTypeParameterInstantiation | null
  ): TSTypeReference;
  declare export function tsTypePredicate(
    parameterName: Identifier | TSThisType,
    typeAnnotation?: TSTypeAnnotation | null,
    asserts?: boolean | null
  ): TSTypePredicate;
  declare export function tsTypeQuery(
    exprName: TSEntityName | TSImportType
  ): TSTypeQuery;
  declare export function tsTypeLiteral(
    members: TSTypeElement[]
  ): TSTypeLiteral;
  declare export function tsArrayType(elementType: TSType): TSArrayType;
  declare export function tsTupleType(
    elementTypes: Array<TSNamedTupleMember | TSType>
  ): TSTupleType;
  declare export function tsOptionalType(
    typeAnnotation: TSType
  ): TSOptionalType;
  declare export function tsRestType(typeAnnotation: TSType): TSRestType;
  declare export function tsNamedTupleMember(
    label: Identifier,
    elementType: TSType,
    optional?: boolean
  ): TSNamedTupleMember;
  declare export function tsUnionType(types: TSType[]): TSUnionType;
  declare export function tsIntersectionType(
    types: TSType[]
  ): TSIntersectionType;
  declare export function tsConditionalType(
    checkType: TSType,
    extendsType: TSType,
    trueType: TSType,
    falseType: TSType
  ): TSConditionalType;
  declare export function tsInferType(
    typeParameter: TSTypeParameter
  ): TSInferType;
  declare export function tsParenthesizedType(
    typeAnnotation: TSType
  ): TSParenthesizedType;
  declare export function tsTypeOperator(
    typeAnnotation: TSType
  ): TSTypeOperator;
  declare export function tsIndexedAccessType(
    objectType: TSType,
    indexType: TSType
  ): TSIndexedAccessType;
  declare export function tsMappedType(
    typeParameter: TSTypeParameter,
    typeAnnotation?: TSType | null,
    nameType?: TSType | null
  ): TSMappedType;
  declare export function tsLiteralType(
    literal: | BigIntLiteral
      | BooleanLiteral
      | NumericLiteral
      | StringLiteral
      | UnaryExpression
  ): TSLiteralType;
  declare export function tsExpressionWithTypeArguments(
    expression: TSEntityName,
    typeParameters?: TSTypeParameterInstantiation | null
  ): TSExpressionWithTypeArguments;
  declare export function tsInterfaceDeclaration(
    id: Identifier,
    typeParameters: TSTypeParameterDeclaration | null | void,
    _extends: TSExpressionWithTypeArguments[] | null | void,
    body: TSInterfaceBody
  ): TSInterfaceDeclaration;
  declare export function tsInterfaceBody(
    body: TSTypeElement[]
  ): TSInterfaceBody;
  declare export function tsTypeAliasDeclaration(
    id: Identifier,
    typeParameters: TSTypeParameterDeclaration | null | void,
    typeAnnotation: TSType
  ): TSTypeAliasDeclaration;
  declare export function tsAsExpression(
    expression: Expression,
    typeAnnotation: TSType
  ): TSAsExpression;
  declare export function tsTypeAssertion(
    typeAnnotation: TSType,
    expression: Expression
  ): TSTypeAssertion;
  declare export function tsEnumDeclaration(
    id: Identifier,
    members: TSEnumMember[]
  ): TSEnumDeclaration;
  declare export function tsEnumMember(
    id: Identifier | StringLiteral,
    initializer?: Expression | null
  ): TSEnumMember;
  declare export function tsModuleDeclaration(
    id: Identifier | StringLiteral,
    body: TSModuleBlock | TSModuleDeclaration
  ): TSModuleDeclaration;
  declare export function tsModuleBlock(body: Statement[]): TSModuleBlock;
  declare export function tsImportType(
    argument: StringLiteral,
    qualifier?: TSEntityName | null,
    typeParameters?: TSTypeParameterInstantiation | null
  ): TSImportType;
  declare export function tsImportEqualsDeclaration(
    id: Identifier,
    moduleReference: TSEntityName | TSExternalModuleReference
  ): TSImportEqualsDeclaration;
  declare export function tsExternalModuleReference(
    expression: StringLiteral
  ): TSExternalModuleReference;
  declare export function tsNonNullExpression(
    expression: Expression
  ): TSNonNullExpression;
  declare export function tsExportAssignment(
    expression: Expression
  ): TSExportAssignment;
  declare export function tsNamespaceExportDeclaration(
    id: Identifier
  ): TSNamespaceExportDeclaration;
  declare export function tsTypeAnnotation(
    typeAnnotation: TSType
  ): TSTypeAnnotation;
  declare export function tsTypeParameterInstantiation(
    params: TSType[]
  ): TSTypeParameterInstantiation;
  declare export function tsTypeParameterDeclaration(
    params: TSTypeParameter[]
  ): TSTypeParameterDeclaration;
  declare export function tsTypeParameter(
    constraint: TSType | null | void,
    _default: TSType | null | void,
    name: string
  ): TSTypeParameter;
  declare export function isAnyTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertAnyTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isArgumentPlaceholder(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertArgumentPlaceholder(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isArrayExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertArrayExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isArrayPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertArrayPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isArrayTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertArrayTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isArrowFunctionExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertArrowFunctionExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isAssignmentExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertAssignmentExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isAssignmentPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertAssignmentPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isAwaitExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertAwaitExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBigIntLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBigIntLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBinary(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBinary(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBinaryExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBinaryExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBindExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBindExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBlock(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBlock(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBlockParent(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBlockParent(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBlockStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBlockStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBooleanLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBooleanLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBooleanLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBooleanLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBooleanTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBooleanTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isBreakStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertBreakStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isCallExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertCallExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isCatchClause(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertCatchClause(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClass(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClass(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassImplements(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassImplements(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassPrivateMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassPrivateMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassPrivateProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassPrivateProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isClassProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertClassProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isCompletionStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertCompletionStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isConditional(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertConditional(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isConditionalExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertConditionalExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isContinueStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertContinueStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDebuggerStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDebuggerStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDecimalLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDecimalLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareClass(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareClass(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareExportAllDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareExportAllDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareExportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareExportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareInterface(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareInterface(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareModule(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareModule(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareModuleExports(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareModuleExports(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareOpaqueType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareOpaqueType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareTypeAlias(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareTypeAlias(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclareVariable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclareVariable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDeclaredPredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDeclaredPredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDecorator(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDecorator(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDirective(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDirective(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDirectiveLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDirectiveLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDoExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDoExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isDoWhileStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertDoWhileStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEmptyStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEmptyStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEmptyTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEmptyTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumBooleanBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumBooleanBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumBooleanMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumBooleanMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumDefaultedMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumDefaultedMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumNumberBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumNumberBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumNumberMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumNumberMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumStringBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumStringBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumStringMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumStringMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isEnumSymbolBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertEnumSymbolBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExistsTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExistsTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExportAllDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExportAllDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExportDefaultDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExportDefaultDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExportDefaultSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExportDefaultSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExportNamedDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExportNamedDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExportNamespaceSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExportNamespaceSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExportSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExportSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExpressionStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExpressionStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isExpressionWrapper(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertExpressionWrapper(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFile(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFile(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFlow(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFlow(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFlowBaseAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFlowBaseAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFlowDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFlowDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFlowPredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFlowPredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFlowType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFlowType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFor(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFor(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isForInStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertForInStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isForOfStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertForOfStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isForStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertForStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isForXStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertForXStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFunctionDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFunctionDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFunctionExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFunctionExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFunctionParent(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFunctionParent(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFunctionTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFunctionTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isFunctionTypeParam(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertFunctionTypeParam(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isGenericTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertGenericTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isIfStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertIfStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isImmutable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertImmutable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isImport(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertImport(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isImportAttribute(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertImportAttribute(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isImportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertImportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isImportDefaultSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertImportDefaultSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isImportNamespaceSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertImportNamespaceSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isImportSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertImportSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isIndexedAccessType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertIndexedAccessType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isInferredPredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertInferredPredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isInterfaceDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertInterfaceDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isInterfaceExtends(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertInterfaceExtends(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isInterfaceTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertInterfaceTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isInterpreterDirective(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertInterpreterDirective(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isIntersectionTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertIntersectionTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSX(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSX(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXAttribute(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXAttribute(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXClosingElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXClosingElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXClosingFragment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXClosingFragment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXEmptyExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXEmptyExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXExpressionContainer(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXExpressionContainer(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXFragment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXFragment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXMemberExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXMemberExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXNamespacedName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXNamespacedName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXOpeningElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXOpeningElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXOpeningFragment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXOpeningFragment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXSpreadAttribute(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXSpreadAttribute(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXSpreadChild(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXSpreadChild(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isJSXText(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertJSXText(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isLVal(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertLVal(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isLabeledStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertLabeledStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isLogicalExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertLogicalExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isLoop(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertLoop(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isMemberExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertMemberExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isMetaProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertMetaProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isMiscellaneous(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertMiscellaneous(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isMixedTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertMixedTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isModuleDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertModuleDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isModuleExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertModuleExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isModuleSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertModuleSpecifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNewExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNewExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNoop(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNoop(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNullLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNullLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNullLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNullLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNullableTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNullableTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;

  /**
   * @deprecated Use `isNumericLiteral`
   */
  declare export function isNumberLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;

  /**
   * @deprecated Use `assertNumericLiteral`
   */
  declare export function assertNumberLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNumberLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNumberLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNumberTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNumberTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isNumericLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertNumericLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectTypeCallProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectTypeCallProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectTypeIndexer(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectTypeIndexer(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectTypeInternalSlot(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectTypeInternalSlot(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectTypeProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectTypeProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isObjectTypeSpreadProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertObjectTypeSpreadProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isOpaqueType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertOpaqueType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isOptionalCallExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertOptionalCallExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isOptionalIndexedAccessType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertOptionalIndexedAccessType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isOptionalMemberExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertOptionalMemberExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isParenthesizedExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertParenthesizedExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPattern(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPatternLike(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPatternLike(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPipelineBareFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPipelineBareFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPipelinePrimaryTopicReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPipelinePrimaryTopicReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPipelineTopicExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPipelineTopicExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPlaceholder(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPlaceholder(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPrivate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPrivate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPrivateName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPrivateName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isProgram(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertProgram(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isPureish(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertPureish(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isQualifiedTypeIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertQualifiedTypeIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isRecordExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertRecordExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isRegExpLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertRegExpLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;

  /**
   * @deprecated Use `isRegExpLiteral`
   */
  declare export function isRegexLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;

  /**
   * @deprecated Use `assertRegExpLiteral`
   */
  declare export function assertRegexLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isRestElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertRestElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;

  /**
   * @deprecated Use `isRestElement`
   */
  declare export function isRestProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;

  /**
   * @deprecated Use `assertRestElement`
   */
  declare export function assertRestProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isReturnStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertReturnStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isScopable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertScopable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isSequenceExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertSequenceExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isSpreadElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertSpreadElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;

  /**
   * @deprecated Use `isSpreadElement`
   */
  declare export function isSpreadProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;

  /**
   * @deprecated Use `assertSpreadElement`
   */
  declare export function assertSpreadProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isStandardized(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertStandardized(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isStaticBlock(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertStaticBlock(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isStringLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertStringLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isStringLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertStringLiteralTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isStringTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertStringTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isSuper(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertSuper(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isSwitchCase(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertSwitchCase(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isSwitchStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertSwitchStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isSymbolTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertSymbolTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSAnyKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSAnyKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSArrayType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSArrayType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSAsExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSAsExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSBaseType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSBaseType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSBigIntKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSBigIntKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSBooleanKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSBooleanKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSCallSignatureDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSCallSignatureDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSConditionalType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSConditionalType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSConstructSignatureDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSConstructSignatureDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSConstructorType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSConstructorType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSDeclareFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSDeclareFunction(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSDeclareMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSDeclareMethod(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSEntityName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSEntityName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSEnumDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSEnumDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSEnumMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSEnumMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSExportAssignment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSExportAssignment(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSExpressionWithTypeArguments(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSExpressionWithTypeArguments(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSExternalModuleReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSExternalModuleReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSFunctionType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSFunctionType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSImportEqualsDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSImportEqualsDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSImportType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSImportType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSIndexSignature(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSIndexSignature(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSIndexedAccessType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSIndexedAccessType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSInferType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSInferType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSInterfaceBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSInterfaceBody(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSInterfaceDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSInterfaceDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSIntersectionType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSIntersectionType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSIntrinsicKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSIntrinsicKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSLiteralType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSLiteralType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSMappedType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSMappedType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSMethodSignature(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSMethodSignature(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSModuleBlock(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSModuleBlock(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSModuleDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSModuleDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSNamedTupleMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSNamedTupleMember(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSNamespaceExportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSNamespaceExportDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSNeverKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSNeverKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSNonNullExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSNonNullExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSNullKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSNullKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSNumberKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSNumberKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSObjectKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSObjectKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSOptionalType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSOptionalType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSParameterProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSParameterProperty(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSParenthesizedType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSParenthesizedType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSPropertySignature(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSPropertySignature(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSQualifiedName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSQualifiedName(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSRestType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSRestType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSStringKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSStringKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSSymbolKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSSymbolKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSThisType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSThisType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTupleType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTupleType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeAliasDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeAliasDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeAssertion(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeAssertion(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeOperator(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeOperator(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeParameter(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeParameter(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeParameterDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeParameterDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeParameterInstantiation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeParameterInstantiation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypePredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypePredicate(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeQuery(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeQuery(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSTypeReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSTypeReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSUndefinedKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSUndefinedKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSUnionType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSUnionType(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSUnknownKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSUnknownKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTSVoidKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTSVoidKeyword(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTaggedTemplateExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTaggedTemplateExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTemplateElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTemplateElement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTemplateLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTemplateLiteral(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTerminatorless(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTerminatorless(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isThisExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertThisExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isThisTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertThisTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isThrowStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertThrowStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTopicReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTopicReference(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTryStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTryStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTupleExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTupleExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTupleTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTupleTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeAlias(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeAlias(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeCastExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeCastExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeParameter(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeParameter(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeParameterDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeParameterDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeParameterInstantiation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeParameterInstantiation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeScript(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeScript(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isTypeofTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertTypeofTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isUnaryExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertUnaryExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isUnaryLike(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertUnaryLike(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isUnionTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertUnionTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isUpdateExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertUpdateExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isUserWhitespacable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertUserWhitespacable(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isV8IntrinsicIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertV8IntrinsicIdentifier(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isVariableDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertVariableDeclaration(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isVariableDeclarator(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertVariableDeclarator(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isVariance(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertVariance(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isVoidTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertVoidTypeAnnotation(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isWhile(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertWhile(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isWhileStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertWhileStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isWithStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertWithStatement(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function isYieldExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): boolean;
  declare export function assertYieldExpression(
    node: { [key: string]: mixed } | null | void,
    opts?: { [key: string]: mixed } | null
  ): void;
  declare export function assertNode(obj: mixed): void;
  declare export function createTypeAnnotationBasedOnTypeof(
    type: | 'boolean'
      | 'function'
      | 'number'
      | 'object'
      | 'string'
      | 'symbol'
      | 'undefined'
  ):
    | BooleanTypeAnnotation
    | GenericTypeAnnotation
    | NumberTypeAnnotation
    | StringTypeAnnotation
    | VoidTypeAnnotation;
  declare export function createUnionTypeAnnotation<T: FlowType>(types: [T]): T;
  declare export function createFlowUnionType<T: FlowType>(types: [T]): T;
  declare export function createUnionTypeAnnotation(
    types: $ReadOnlyArray<FlowType>
  ): UnionTypeAnnotation;
  declare export function createFlowUnionType(
    types: $ReadOnlyArray<FlowType>
  ): UnionTypeAnnotation;
  declare export function buildChildren(node: {
    children: $ReadOnlyArray<
      | JSXElement
      | JSXEmptyExpression
      | JSXExpressionContainer
      | JSXFragment
      | JSXSpreadChild
      | JSXText>,
    ...,
  }): JSXElement['children'];
  declare export function clone<T: Node>(n: T): T;
  declare export function cloneDeep<T: Node>(n: T): T;
  declare export function cloneDeepWithoutLoc<T: Node>(n: T): T;
  declare export function cloneNode<T: Node>(
    n: T,
    deep?: boolean,
    withoutLoc?: boolean
  ): T;
  declare export function cloneWithoutLoc<T: Node>(n: T): T;
  declare export

type CommentTypeShorthand = 'inner' | 'leading' | 'trailing';

  declare export function addComment<T: Node>(
    node: T,
    type: CommentTypeShorthand,
    content: string,
    line?: boolean
  ): T;
  declare export function addComments<T: Node>(
    node: T,
    type: CommentTypeShorthand,
    comments: $ReadOnlyArray<Comment>
  ): T;
  declare export function inheritInnerComments(node: Node, parent: Node): void;
  declare export function inheritLeadingComments(
    node: Node,
    parent: Node
  ): void;
  declare export function inheritsComments<T: Node>(
    node: T,
    parent: Node
  ): void;
  declare export function inheritTrailingComments(
    node: Node,
    parent: Node
  ): void;
  declare export function removeComments<T: Node>(node: T): T;
  declare export function ensureBlock(
    node: {
      body: BlockStatement | Expression | Statement,
      ...,
    }
  ): BlockStatement;
  declare export function ensureBlock<
    K: 'body'
  >(
    node: { [key: K]: BlockStatement | Expression | Statement, ... },
    key: K
  ): BlockStatement;
  declare export function toBindingIdentifierName(
    name: {
      toString(): string,
      ...,
    } | null | void
  ): string;
  declare export function toBlock(
    node: Expression | Statement,
    parent?: IFunction | null
  ): BlockStatement;
  declare export function toComputedKey<
    T: {
      computed: boolean | null,
      ...,
    }
  >(
    node: T,
    key?: Expression | Identifier
  ): Expression;
  declare export function toExpression(node: IFunction): FunctionExpression;
  declare export function toExpression(node: IClass): ClassExpression;
  declare export function toExpression(
    node: Expression | ExpressionStatement | IClass | IFunction
  ): Expression;
  declare export function toIdentifier(
    name: {
      toString(): string,
      ...,
    } | null | void
  ): string;
  declare export function toKeyAlias(
    node: Method | Property,
    key?: Node
  ): string;
  declare export function toSequenceExpression(
    nodes: $ReadOnlyArray<Node>,
    scope: {
      buildUndefinedNode(): Node,
      push(value: {
        id: LVal,
        init?: Expression,
        kind: 'var',
        ...,
      }): void,
      ...,
    }
  ): SequenceExpression | void;
  declare export function toStatement(
    node: AssignmentExpression,
    ignore?: boolean
  ): ExpressionStatement;
  declare export function toStatement(
    node: AssignmentExpression | Statement,
    ignore?: boolean
  ): Statement;
  declare export function toStatement(
    node: IClass,
    ignore: true
  ): ClassDeclaration | void;
  declare export function toStatement(
    node: IClass,
    ignore?: boolean
  ): ClassDeclaration;
  declare export function toStatement(
    node: IFunction,
    ignore: true
  ): FunctionDeclaration | void;
  declare export function toStatement(
    node: IFunction,
    ignore?: boolean
  ): FunctionDeclaration;
  declare export function toStatement(
    node: AssignmentExpression | IClass | IFunction | Statement,
    ignore: true
  ): Statement | void;
  declare export function toStatement(
    node: AssignmentExpression | IClass | IFunction | Statement,
    ignore?: boolean
  ): Statement;
  declare export function valueToNode(value: void): Identifier;
  declare export function valueToNode(value: boolean): BooleanLiteral;
  declare export function valueToNode(value: null): NullLiteral;
  declare export function valueToNode(value: string): StringLiteral;
  declare export function valueToNode(
    value: number
  ): BinaryExpression | NumericLiteral | UnaryExpression;
  declare export function valueToNode(value: RegExp): RegExpLiteral;
  declare export function valueToNode(
    value: $ReadOnlyArray<
      | boolean
      | number
      | string
      | RegExp
      | { [key: string]: mixed }
      | null
      | void>
  ): ArrayExpression;
  declare export function valueToNode(value: {
    [key: string]: mixed,
  }): ObjectExpression;
  declare export function valueToNode(
    value: | boolean
      | number
      | string
      | RegExp
      | { [key: string]: mixed }
      | null
      | void
  ): Expression;
  declare export function removeTypeDuplicates(
    types: $ReadOnlyArray<FlowType | false | null | void>
  ): FlowType[];
  declare export function appendToMemberExpression<
    T: {
      object: MemberExpression['object'],
      property: MemberExpression['property'],
      ...,
    }
  >(
    member: T,
    append: MemberExpression['property'],
    computed?: boolean
  ): T;
  declare export function inherits<T: Node | null | void>(
    child: T,
    parent: Node | null | void
  ): T;
  declare export function prependToMemberExpression<
    T: {
      object: MemberExpression['object'],
      property: MemberExpression['property'],
      ...,
    }
  >(
    member: T,
    prepend: MemberExpression['object']
  ): T;
  declare export function removeProperties(
    n: Node,
    opts?: {
      preserveComments: boolean,
      ...,
    } | null
  ): void;
  declare export function removePropertiesDeep<T: Node>(
    n: T,
    opts?: {
      preserveComments: boolean,
      ...,
    } | null
  ): T;
  declare export function getBindingIdentifiers(
    node: Node,
    duplicates: true,
    outerOnly?: boolean
  ): { [key: string]: Identifier[], ... };
  declare export function getBindingIdentifiers(
    node: Node,
    duplicates?: false,
    outerOnly?: boolean
  ): { [key: string]: Identifier, ... };
  declare export function getBindingIdentifiers(
    node: Node,
    duplicates: boolean,
    outerOnly?: boolean
  ): { [key: string]: Identifier | Identifier[], ... };
  declare export function getOuterBindingIdentifiers(
    node: Node,
    duplicates: true
  ): { [key: string]: Identifier[], ... };
  declare export function getOuterBindingIdentifiers(
    node: Node,
    duplicates?: false
  ): { [key: string]: Identifier, ... };
  declare export function getOuterBindingIdentifiers(
    node: Node,
    duplicates: boolean
  ): { [key: string]: Identifier | Identifier[], ... };
  declare export

type TraversalAncestors = $ReadOnlyArray<{
    index?: number,
    key: string,
    node: Node,
    ...,
  }>;

  declare export type TraversalHandler<T> = (
    node: Node,
    parent: TraversalAncestors,
    type: T
  ) => void;

  declare export type TraversalHandlers<T> = {
    enter?: TraversalHandler<T>,
    exit?: TraversalHandler<T>,
    ...,
  };

  declare export function traverse<T>(
    n: Node,
    h: TraversalHandler<T> | TraversalHandlers<T>,
    state?: T
  ): void;
  declare export function traverseFast<T>(
    n: Node,
    h: TraversalHandler<T>,
    state?: T
  ): void;
  declare export function shallowEqual<T: { [key: string]: mixed }>(
    actual: { [key: string]: mixed },
    expected: T
  ): boolean;
  declare export function buildMatchMemberExpression(
    match: string,
    allowPartial?: boolean
  ): (node: Node | null | void) => boolean;
  declare export function is<T: Node['type']>(
    type: T,
    n: Node | null | void,
    required?: void
  ): boolean;
  declare export function is<
    T: Node['type'],
    P: {
      type: T,
      ...,
    }
  >(
    type: T,
    n: Node | null | void,
    required: $Rest<P, { ... }>
  ): boolean;
  declare export function is<P: Node>(
    type: string,
    n: Node | null | void,
    required: $Rest<P, { ... }>
  ): boolean;
  declare export function is(
    type: string,
    n: Node | null | void,
    required?: $Rest<Node, { ... }>
  ): boolean;
  declare export function isBinding(
    node: Node,
    parent: Node,
    grandparent?: Node
  ): boolean;
  declare export function isBlockScoped(node: Node): boolean;
  declare export function isImmutable(node: Node): boolean;
  declare export function isLet(node: Node): boolean;
  declare export function isNode(
    node: { [key: string]: mixed } | null | void
  ): boolean;
  declare export function isNodesEquivalent<T: $Rest<Node, { ... }>>(
    a: T,
    b: mixed
  ): boolean;
  declare export function isNodesEquivalent(a: mixed, b: mixed): boolean;
  declare export function isPlaceholderType(
    placeholderType: Node['type'],
    targetType: Node['type']
  ): boolean;
  declare export function isReferenced(
    node: Node,
    parent: Node,
    grandparent?: Node
  ): boolean;
  declare export function isScope(node: Node, parent: Node): boolean;
  declare export function isSpecifierDefault(
    specifier: ModuleSpecifier
  ): boolean;
  declare export function isType<T: Node['type']>(
    nodetype: string,
    targetType: T
  ): boolean;
  declare export function isType(
    nodetype: string | null | void,
    targetType: string
  ): boolean;
  declare export function isValidES3Identifier(name: string): boolean;
  declare export function isValidIdentifier(name: string): boolean;
  declare export function isVar(node: Node): boolean;
  declare export function matchesPattern(
    node: Node | null | void,
    match: string | $ReadOnlyArray<string>,
    allowPartial?: boolean
  ): boolean;
  declare export function validate<T: Node, K: $Keys<T>>(
    n: Node | null | void,
    key: K,
    value: T[K]
  ): void;
  declare export function validate(n: Node, key: string, value: mixed): void;
}
